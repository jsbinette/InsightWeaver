{
  "version": 3,
  "sources": ["../../src/tags/tree-data.ts", "../../src/utilities/utility.service.ts"],
  "sourcesContent": ["'use strict';\n\nimport * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\nimport { getExtensionConfig } from '../utilities/utility.service';\nimport { InstructionsController } from './controller';\n\n\nclass InstructionsDataModel {\n    private controller: InstructionsController;\n\n    constructor(controller: InstructionsController) {\n        this.controller = controller;\n    }\n\n    getRoot(): TreeElement[] {\n        let fileTags = Object.keys(this.controller.tags);\n\n        if (getExtensionConfig().view.showVisibleFilesOnly) {\n            let visibleEditorUris: string[];\n\n            if (getExtensionConfig().view.showVisibleFilesOnlyMode === 'onlyActiveEditor') {\n                const activeEditor = vscode.window.activeTextEditor;\n                visibleEditorUris = activeEditor ? [activeEditor.document.uri.path] : [];\n            } else {\n                visibleEditorUris = vscode.window.visibleTextEditors.map((te) => te.document.uri.path);\n            }\n\n            fileTags = fileTags.filter((v) =>\n                visibleEditorUris.includes(vscode.Uri.parse(v).path)\n            );\n        }\n\n        return fileTags.sort().map((v) => ({\n            resource: vscode.Uri.parse(v),\n            tooltip: v,\n            name: v,\n            type: NodeType.FILE,\n            parent: null,\n            iconPath: vscode.ThemeIcon.File,\n            location: null,\n            label: path.basename(vscode.Uri.parse(v).fsPath)\n        }));\n    }\n\n    getChildren(element: TreeElement): TreeElement[] {\n        if (element.type === NodeType.FILE) {\n            const extractTextAfterLastAtWord = (inputString: string): string => {\n                const zeroedRegex = /^@summarize\\([^)]*\\)\\s*/;\n                const zeroedMatch = inputString.match(zeroedRegex);\n                if (zeroedMatch) {\n                    return zeroedMatch[0].trim();\n                }\n\n                const firstRegex = /@[\\w-]+[^@]*$/;\n                const firstMatch = inputString.match(firstRegex);\n\n                if (firstMatch) {\n                    let remainingText = firstMatch[0];\n                    let secondRegex: RegExp;\n\n                    while (true) {\n                        if (remainingText.startsWith('@summarize(')) {\n                            secondRegex = /^@summarize\\([^)]*\\)\\s*/;\n                        } else {\n                            secondRegex = /^@[\\w-]+\\s+/;\n                        }\n\n                        const secondMatch = remainingText.match(secondRegex);\n\n                        if (secondMatch) {\n                            remainingText = remainingText.substring(secondMatch[0].length);\n                        } else {\n                            break;\n                        }\n                    }\n\n                    return remainingText.trim();\n                }\n\n                return '';\n            };\n\n            const tags = Object.keys(this.controller.tags[element.name]).flatMap((cat) => {\n                return this.controller.tags[element.name][cat].map((v: any) => {\n                    const location = new vscode.Location(element.resource, v.range);\n                    return {\n                        resource: element.resource,\n                        location: location,\n                        label: extractTextAfterLastAtWord(v.text),\n                        name: v.text.trim(),\n                        type: NodeType.LOCATION,\n                        category: cat,\n                        parent: element,\n                        iconPath: this.controller.styles[cat]?.options?.gutterIconPath,\n                    };\n                });\n            });\n\n            return tags.sort((a, b) => a.location!.range.start.line - b.location!.range.start.line);\n        }\n\n        return [];\n    }\n\n    getNeighbors(element: TreeElement): { previous: TreeElement | null; next: TreeElement | null } {\n        const ret: { previous: TreeElement | null; next: TreeElement | null } = { previous: null, next: null };\n        let parent = element.parent;\n\n        if (!parent) {\n            parent = { ...element, type: NodeType.FILE, name: element.resource.toString() } as TreeElement;\n        }\n\n        const tags = this.getChildren(parent);\n\n        let gotElement = false;\n\n        for (const b of tags) {\n            if (!gotElement && JSON.stringify(b.location) === JSON.stringify(element.location)) {\n                gotElement = true;\n                continue;\n            }\n\n            if (!gotElement) {\n                ret.previous = b;\n            } else {\n                ret.next = b;\n                break;\n            }\n        }\n\n        return ret;\n    }\n}\n\n\nexport class TagsTreeDataProvider implements vscode.TreeDataProvider<TreeElement> {\n    private _onDidChangeTreeData: vscode.EventEmitter<TreeElement | undefined | null | void> = new vscode.EventEmitter<TreeElement | undefined | null | void>();\n    readonly onDidChangeTreeData: vscode.Event<TreeElement | undefined | null | void> = this._onDidChangeTreeData.event;\n\n    private controller: any; // Replace `any` with the actual type of your instructionsController\n    public model: InstructionsDataModel;\n    private filterTreeViewWords: string[];\n    private gitIgnoreHandler: { filter: (resource: vscode.Uri) => boolean } | undefined;\n\n    constructor(instructionsController: any) {\n        this.controller = instructionsController;\n        this.model = new InstructionsDataModel(instructionsController);\n        this.filterTreeViewWords = [];\n        this.gitIgnoreHandler = undefined;\n    }\n\n    /** TreeDataProvider Methods */\n\n    public getChildren(element?: TreeElement): Thenable<TreeElement[]> {\n        const elements = element ? this.model.getChildren(element) : this.model.getRoot();\n        return Promise.resolve(this._filterTreeView(elements));\n    }\n\n    getParent(element: TreeElement): TreeElement | null {\n        return element.parent || null;\n    }\n\n    getTreeItem(element: TreeElement): vscode.TreeItem {\n        let label = this._formatLabel(element.label)\n        if (label == undefined) {\n            label = \"\"\n        }\n        const item = new vscode.TreeItem(\n            label, // Pass a valid label\n            element.type === NodeType.LOCATION\n                ? vscode.TreeItemCollapsibleState.None\n                : getExtensionConfig().view.expanded\n                    ? vscode.TreeItemCollapsibleState.Expanded\n                    : vscode.TreeItemCollapsibleState.Collapsed\n        );\n\n        item.id =\n            element.type === NodeType.LOCATION && element.location\n                ? this._getId(element.location)\n                : this._getId(element.resource);\n\n        item.resourceUri = element.resource;\n        item.iconPath = element.iconPath;\n        item.command =\n            element.type === NodeType.LOCATION && element.location\n                ? {\n                    command: \"instructions-manager.jumpToRange\",\n                    arguments: [element.location.uri, element.location.range],\n                    title: \"JumpTo\",\n                }\n                : undefined;\n\n        return item;\n    }\n\n    /** Utility Methods */\n\n    private _getId(o: vscode.Location | vscode.Uri): string {\n        return crypto.createHash('sha1').update(JSON.stringify(o)).digest('hex');\n    }\n\n    private _formatLabel(label?: string): string | undefined {\n        if (!getExtensionConfig().view.words.hide || !label) {\n            return label;\n        }\n        const words = Object.values(this.controller.words).flat() as string[];\n        return words.reduce((prevs, word) => prevs.replace(new RegExp(word, 'g'), ''), label);\n    }\n\n    private _filterTreeView(elements: TreeElement[]): TreeElement[] {\n        if (this.gitIgnoreHandler?.filter) {\n            elements = elements.filter((e) => this.gitIgnoreHandler!.filter(e.resource));\n        }\n\n        if (this.filterTreeViewWords.length) {\n            elements = elements.filter((e) =>\n                this.filterTreeViewWords.some((rx) => new RegExp(rx, 'g').test(e.label || ''))\n            );\n        }\n\n        return elements;\n    }\n\n    /** Public Methods */\n\n    setTreeViewFilterWords(words: string[]): void {\n        this.filterTreeViewWords = words;\n    }\n\n    setTreeViewGitIgnoreHandler(gi: { filter: (resource: vscode.Uri) => boolean }): void {\n        this.gitIgnoreHandler = gi;\n    }\n\n    refresh(): void {\n        this._onDidChangeTreeData.fire();\n    }\n}\n\nenum NodeType {\n    FILE = 1,\n    LOCATION = 2,\n}\n\nexport interface TreeElement {\n    resource: vscode.Uri;\n    tooltip?: string;\n    name: string;\n    type: NodeType;\n    parent: TreeElement | null;\n    iconPath: vscode.ThemeIcon | string | undefined;\n    location?: vscode.Location | null;\n    label?: string;\n    category?: string;\n}", "import { Uri, Webview } from \"vscode\";\nimport * as vscode from \"vscode\";\nimport EventEmitter = require('events');\n\nexport function getExtensionConfig(): vscode.WorkspaceConfiguration {\n    return vscode.workspace.getConfiguration('instructions-manager');\n}\n\n\n/**\n * Click history question event emitter.\n */\nconst clickHistoryQuestionEventEmitter = new EventEmitter();\nexport { clickHistoryQuestionEventEmitter }\n\n/**\n * Fire history question event.\n * @param historyQuestion :string \n*/\nexport function FireClickHistoryQuestionEvent(historyQuestion: string) {\n  clickHistoryQuestionEventEmitter.emit('clickHistoryQuestion', historyQuestion);\n}\n\n/**\n * Gets nonce\n * @returns string\n */\nexport function getNonce() {\n  let text = \"\";\n  const possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  for (let i = 0; i < 32; i++) {\n    text += possible.charAt(Math.floor(Math.random() * possible.length));\n  }\n  return text;\n}\n\n/**\n * Create a vscode.Uri as WebviewUri for source files.\n * @param webview :vscode.Weview\n * @param extensionUri :vscode.Uri\n * @param pathList :string[]\n * @returns vscode.Uri\n */\nexport function getAsWebviewUri(webview: Webview, extensionUri: Uri, pathList: string[]) {\n  return webview.asWebviewUri(Uri.joinPath(extensionUri, ...pathList));\n}\n\n/**\n * Create a vscode.Uri for source files.\n * @param extensionUri :vscode.Uri\n * @param pathList :strig[]\n * @returns vscode.Uri\n */\nexport function getVSCodeUri(extensionUri: Uri, pathList: string[]) {\n  return vscode.Uri.joinPath(extensionUri, ...pathList);\n}\n\n/**\n * Set storeData into context.globalState.\n * @param context :vscode.ExtensionContext\n * @param storeData : any\n */\nexport function setStoreData(context: vscode.ExtensionContext, storeData: any) {\n  const state = globalStateManager(context);\n\n  if (storeData !== undefined) {\n    state.write({\n      storeData: storeData\n    });\n  }\n}\n\nexport function setHistoryData(context: vscode.ExtensionContext, historyData: any) {\n  const state = globalStateManager(context);\n\n  if (historyData !== undefined) {\n    state.writeHistory({\n      historyData: historyData\n    });\n  }\n}\n\nexport function setChatData(context: vscode.ExtensionContext, chatData: any) {\n  const state = globalStateManager(context);\n\n  if (chatData !== undefined) {\n    state.writeChat({\n      chatData: chatData\n    });\n  }\n}\n\n/**\n * Gets storeData from context.globalState.\n * @param context :vscode.ExtensionContext\n * @returns string\n */\nexport function getStoreData(context: vscode.ExtensionContext): any {\n  const state = globalStateManager(context);\n\n  const { storeData } = state.read();\n  return storeData as any;\n}\n\nexport function getHistoryData(context: vscode.ExtensionContext): any {\n  const state = globalStateManager(context);\n\n  const { historyData } = state.readHistory();\n  return historyData as any;\n}\n\nexport function getChatData(context: vscode.ExtensionContext): any {\n  const state = globalStateManager(context);\n\n  const { chatData } = state.readChat();\n  return chatData as any;\n}\n\n/**\n* State Manager has read and write methods for api key. This methods set and get the api key from context.globalState.\n* @param context :vscode.ExtensionContext.\n* @returns void.\n*/\nexport function globalStateManager(context: vscode.ExtensionContext) {\n  return {\n    read,\n    write,\n    writeHistory,\n    readHistory,\n    writeChat,\n    readChat,\n  };\n\n  function read() {\n    return {\n      storeData: context.globalState.get('storeData')\n    };\n  }\n  \n  function readHistory() {\n    var historyData =  context.globalState.get('historyData')\n    if(historyData == undefined){\n      historyData = [];\n    }\n    return {\n      historyData\n    };\n  }\n\n  function readChat() {\n    var chatData =  context.globalState.get('chatData')\n    if(chatData == undefined){\n      chatData = [];\n    }\n    return {\n      chatData\n    };\n  }\n\n  function write(newState: any) {\n    context.globalState.update('storeData', newState.storeData);\n  }\n\n  function writeChat(newState: any) {\n    context.globalState.update('chatData', newState.chatData);\n  }\n\n  function writeHistory(newState: any) {\n    context.globalState.update('historyData', newState.historyData);\n  }\n}\n\n"],
  "mappings": "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",
  "names": ["vscode", "NodeType"]
}
