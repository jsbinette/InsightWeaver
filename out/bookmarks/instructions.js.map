{
  "version": 3,
  "sources": ["../../node_modules/balanced-match/index.js", "../../node_modules/brace-expansion/index.js", "../../src/bookmarks/instructions.ts", "../../node_modules/minimatch/src/index.ts", "../../node_modules/minimatch/src/assert-valid-pattern.ts", "../../node_modules/minimatch/src/brace-expressions.ts", "../../node_modules/minimatch/src/unescape.ts", "../../node_modules/minimatch/src/ast.ts", "../../node_modules/minimatch/src/escape.ts", "../../src/settings.ts"],
  "sourcesContent": ["'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    if(a===b) {\n      return [ai, bi];\n    }\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n", "var balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m) return [str];\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  if (/\\$$/.test(m.pre)) {    \n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre+ '{' + m.body + '}' + post[k];\n      expansions.push(expansion);\n    }\n  } else {\n    var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isSequence = isNumericSequence || isAlphaSequence;\n    var isOptions = m.body.indexOf(',') >= 0;\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,.*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post;\n        return expand(str);\n      }\n      return [str];\n    }\n\n    var n;\n    if (isSequence) {\n      n = m.body.split(/\\.\\./);\n    } else {\n      n = parseCommaParts(m.body);\n      if (n.length === 1) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand(n[0], false).map(embrace);\n        if (n.length === 1) {\n          return post.map(function(p) {\n            return m.pre + n[0] + p;\n          });\n        }\n      }\n    }\n\n    // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n    var N;\n\n    if (isSequence) {\n      var x = numeric(n[0]);\n      var y = numeric(n[1]);\n      var width = Math.max(n[0].length, n[1].length)\n      var incr = n.length == 3\n        ? Math.abs(numeric(n[2]))\n        : 1;\n      var test = lte;\n      var reverse = y < x;\n      if (reverse) {\n        incr *= -1;\n        test = gte;\n      }\n      var pad = n.some(isPadded);\n\n      N = [];\n\n      for (var i = x; test(i, y); i += incr) {\n        var c;\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i);\n          if (c === '\\\\')\n            c = '';\n        } else {\n          c = String(i);\n          if (pad) {\n            var need = width - c.length;\n            if (need > 0) {\n              var z = new Array(need + 1).join('0');\n              if (i < 0)\n                c = '-' + z + c.slice(1);\n              else\n                c = z + c;\n            }\n          }\n        }\n        N.push(c);\n      }\n    } else {\n      N = [];\n\n      for (var j = 0; j < n.length; j++) {\n        N.push.apply(N, expand(n[j], false));\n      }\n    }\n\n    for (var j = 0; j < N.length; j++) {\n      for (var k = 0; k < post.length; k++) {\n        var expansion = pre + N[j] + post[k];\n        if (!isTop || isSequence || expansion)\n          expansions.push(expansion);\n      }\n    }\n  }\n\n  return expansions;\n}\n\n", "'use strict';\n\n/**\n * @author github.com/tintinweb\n * @author github.com/jsbinette\n */\n\n/** Imports */\nimport * as vscode from 'vscode';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\nimport * as os from 'os';\nimport { minimatch } from 'minimatch';\nimport * as settings from '../settings';\n\nclass Commands {\n    private controller: InstructionsController;\n\n    constructor(controller: InstructionsController) {\n        this.controller = controller;\n    }\n\n    refresh(): void {\n        Object.keys(this.controller.bookmarks).forEach((uri) => {\n            vscode.workspace.openTextDocument(vscode.Uri.parse(uri)).then((document) => {\n                this.controller.updateBookmarks(document);\n            });\n        });\n    }\n\n    showSelectBookmark(filter?: (resource: string) => boolean, placeHolder?: string): void {\n        const entries: CustomEntry[] = [];\n\n        Object.keys(this.controller.bookmarks).forEach((uri) => {\n            const resource = vscode.Uri.parse(uri).fsPath;\n            const fname = path.parse(resource).base;\n\n            if (filter && !filter(resource)) {\n                return;\n            }\n\n            Object.keys(this.controller.bookmarks[uri]).forEach((cat) => {\n                this.controller.bookmarks[uri][cat].forEach((b) => {\n                    entries.push({\n                        label: b.text,\n                        description: fname,\n                        target: new vscode.Location(vscode.Uri.file(resource), b.range),\n                    });\n                });\n            });\n        });\n\n        vscode.window\n            .showQuickPick(entries, { placeHolder: placeHolder || 'Select bookmarks' })\n            .then((item) => {\n                if (item && (item as any).target) {\n                    vscode.commands.executeCommand(\n                        'instructions.jumpToRange',\n                        (item as any).target.uri,\n                        (item as any).target.range\n                    );\n                }\n            });\n    }\n\n    showSelectVisibleBookmark(): void {\n        const visibleEditorUris = vscode.window.visibleTextEditors.map((te) => te.document.uri.fsPath);\n        this.showSelectBookmark((resFsPath) => visibleEditorUris.includes(resFsPath), 'Select visible bookmarks');\n    }\n\n    showListBookmarks(filter?: (resource: string) => boolean): void {\n        if (!vscode.window.createOutputChannel) return;\n\n        const outputChannel = vscode.window.createOutputChannel('instructions');\n        outputChannel.clear();\n\n        const entries: { label: string; description: string; target: vscode.Location }[] = [];\n\n        Object.keys(this.controller.bookmarks).forEach((uri) => {\n            const resource = vscode.Uri.parse(uri).fsPath;\n            const fname = path.parse(resource).base;\n\n            if (filter && !filter(resource)) {\n                return;\n            }\n\n            Object.keys(this.controller.bookmarks[uri]).forEach((cat) => {\n                this.controller.bookmarks[uri][cat].forEach((b) => {\n                    entries.push({\n                        label: b.text,\n                        description: fname,\n                        target: new vscode.Location(vscode.Uri.file(resource), b.range),\n                    });\n                });\n            });\n        });\n\n        if (entries.length === 0) {\n            vscode.window.showInformationMessage('No results');\n            return;\n        }\n\n        entries.forEach((v, i) => {\n            const patternA = `#${i + 1}\\t${v.target.uri}#${v.target.range.start.line + 1}`;\n            const patternB = `#${i + 1}\\t${v.target.uri}:${v.target.range.start.line + 1}:${v.target.range.start.character + 1}`;\n            const patternType = os.platform() === 'linux' ? 1 : 0;\n\n            outputChannel.appendLine([patternA, patternB][patternType]);\n            outputChannel.appendLine(`\\t${v.label}\\n`);\n        });\n\n        outputChannel.show();\n    }\n\n    showListVisibleBookmarks(): void {\n        const visibleEditorUris = vscode.window.visibleTextEditors.map((te) => te.document.uri.fsPath);\n        this.showListBookmarks((resFsPath) => visibleEditorUris.includes(resFsPath));\n    }\n\n    scanWorkspaceBookmarks(): void {\n        vscode.workspace\n            .findFiles(this.controller.includePattern, this.controller.excludePattern, this.controller.maxFilesLimit)\n            .then(\n                (files) => {\n                    if (!files || files.length === 0) {\n                        console.log('No files found');\n                        return;\n                    }\n\n                    function isTextFile(filePath: string): boolean {\n                        const buffer = fs.readFileSync(filePath, { encoding: null, flag: 'r' });\n                        const textChars = buffer.toString('utf8').split('').filter(char => {\n                            const code = char.charCodeAt(0);\n                            return (code >= 32 && code <= 126) || code === 9 || code === 10 || code === 13;\n                        });\n                    \n                        return textChars.length / buffer.length > 0.9; // Adjust the threshold as needed\n                    }\n                    \n                    files.forEach((file) => {\n                        if (isTextFile(file.fsPath)) {\n                            vscode.workspace.openTextDocument(file).then(\n                                (document) => {\n                                    this.controller.updateBookmarks(document);\n                                },\n                                (err) => console.error(err)\n                            );\n                        }\n                    });\n                },\n                (err) => console.error(err)\n            );\n    }\n}\n\n\ninterface Bookmark {\n    range: vscode.Range;\n    text: string;\n}\n\ntype Bookmarks = {\n    [file: string]: {\n        [style: string]: Bookmark[];\n    };\n}\n\ninterface CustomEntry {\n    label: string;\n    description: string;\n    target: vscode.Location;\n}\n\ninterface FileDataEntry {\n    line: number;\n    startCharacter: number;\n    endCharacter: number;\n    tag: string;\n    tagText: string;\n}\n\ntype TransformedData = {\n    [filePath: string]: FileDataEntry[];\n};\n\nclass InstructionsController {\n    private context: vscode.ExtensionContext;\n    public styles: Record<string, any>;\n    private words: Record<string, string[]>;\n    public commands: any;\n    public bookmarks: Bookmarks;\n\n    public includePattern: string;\n    public excludePattern: string;\n    public maxFilesLimit: number;\n\n    constructor(context: vscode.ExtensionContext) {\n        this.context = context;\n        this.styles = this._reLoadDecorations();\n        this.words = this._reLoadWords();\n\n        this.commands = new Commands(this);\n\n        this.bookmarks = {}; // { file: { bookmark } }\n\n        const arrayToSearchGlobPattern = (config: string | string[]): string => {\n            return Array.isArray(config)\n                ? `{${config.join(',')}}`\n                : typeof config === 'string'\n                    ? config\n                    : '';\n        };\n\n        this.includePattern = arrayToSearchGlobPattern(settings.extensionConfig().search.includes) || '{**/*}';\n        this.excludePattern = arrayToSearchGlobPattern(settings.extensionConfig().search.excludes);\n        this.maxFilesLimit = settings.extensionConfig().search.maxFiles;\n\n        this.loadFromWorkspace();\n    }\n\n    /** -- public -- */\n\n    hasBookmarks(): boolean {\n        return !!Object.keys(this.bookmarks).length;\n    }\n\n    async decorate(editor: vscode.TextEditor): Promise<void> {\n        if (!editor || !editor.document) return;\n        if (minimatch(editor.document.fileName, this.excludePattern)) return;\n\n        this._clearBookmarksOfFile(editor.document);\n\n        if (this._extensionIsBlacklisted(editor.document.fileName)) return;\n\n        for (const style in this.words) {\n            if (\n                !this.words.hasOwnProperty(style) ||\n                this.words[style].length === 0 ||\n                this._wordIsOnIgnoreList(this.words[style])\n            ) {\n                continue;\n            }\n            await this._decorateWords(editor, this.words[style], style, editor.document.fileName.startsWith('extension-output-'));\n        }\n\n        this.saveToWorkspace();\n    }\n\n    async updateBookmarks(document: vscode.TextDocument): Promise<void> {\n        if (!document || document.fileName.startsWith('extension-output-')) return;\n\n        this._clearBookmarksOfFile(document);\n\n        if (this._extensionIsBlacklisted(document.fileName)) return;\n\n        for (const style in this.words) {\n            if (\n                !this.words.hasOwnProperty(style) ||\n                this.words[style].length === 0 ||\n                this._wordIsOnIgnoreList(this.words[style])\n            ) {\n                continue;\n            }\n            await this._updateBookmarksForWordAndStyle(document, this.words[style], style);\n        }\n\n        this.saveToWorkspace();\n    }\n\n    /** -- private -- */\n\n    private _extensionIsBlacklisted(fileName: string): boolean {\n        const ignoreList = settings.extensionConfig().exceptions.file.extensions.ignore;\n        if (!ignoreList || ignoreList.length === 0) return false;\n        if (minimatch(fileName, this.excludePattern)) return false;\n        return this._commaSeparatedStringToUniqueList(ignoreList).some((ext) => fileName.endsWith(ext.trim()));\n    }\n\n    private _wordIsOnIgnoreList(words: string[]): boolean {\n        const ignoreList = settings.extensionConfig().exceptions.words.ignore;\n        return this._commaSeparatedStringToUniqueList(ignoreList).some((ignoreWord) =>\n            words.some((word) => word.startsWith(ignoreWord.trim()))\n        );\n    }\n\n    private _commaSeparatedStringToUniqueList(input: string): string[] {\n        if (!input) return [];\n        return [...new Set(input.trim().split(',').map((e) => e.trim()).filter((e) => e.length))];\n    }\n\n    private async _decorateWords(\n        editor: vscode.TextEditor,\n        words: string[],\n        style: string,\n        noAdd: boolean\n    ): Promise<void> {\n        const decoStyle = this.styles[style]?.type || this.styles['default'].type;\n\n        const locations = this._findWords(editor.document, words);\n        editor.setDecorations(decoStyle, locations);\n\n        if (locations.length && !noAdd) {\n            this._addBookmark(editor.document, style, locations);\n        }\n    }\n\n    private async _updateBookmarksForWordAndStyle(\n        document: vscode.TextDocument,\n        words: string[],\n        style: string\n    ): Promise<void> {\n        const locations = this._findWords(document, words);\n\n        if (locations.length) {\n            this._addBookmark(document, style, locations);\n        }\n    }\n\n    private _findWords(document: vscode.TextDocument, words: string[]): { range: vscode.Range; text: string }[] {\n        const text = document.getText();\n        const locations: { range: vscode.Range; text: string }[] = [];\n\n        words.forEach((word) => {\n            const regEx = new RegExp(word, 'g');\n            let match;\n            while ((match = regEx.exec(text))) {\n                const startPos = document.positionAt(match.index);\n                const endPos = document.positionAt(match.index + match[0].trim().length);\n\n                const fullLine = document.getWordRangeAtPosition(startPos, /(.+)$/);\n\n                if (fullLine) {\n                    locations.push({\n                        range: new vscode.Range(startPos, endPos),\n                        text: document.getText(fullLine),\n                    });\n                }\n            }\n        });\n\n        return locations;\n    }\n\n    private _clearBookmarksOfFile(document: vscode.TextDocument): void {\n        const filename = document.uri.toString();\n        if (!this.bookmarks.hasOwnProperty(filename)) return;\n        delete this.bookmarks[filename];\n    }\n\n    private _addBookmark(\n        document: vscode.TextDocument,\n        style: string,\n        locations: { range: vscode.Range; text: string }[]\n    ): void {\n        const filename = document.uri.toString();\n        if (!this.bookmarks.hasOwnProperty(filename)) {\n            this.bookmarks[filename] = {};\n        }\n        this.bookmarks[filename][style] = locations;\n    }\n\n    private _reLoadWords(): Record<string, string[]> {\n        const defaultWords = {\n            blue: this._commaSeparatedStringToUniqueList(settings.extensionConfig().default.words.blue),\n            purple: this._commaSeparatedStringToUniqueList(settings.extensionConfig().default.words.purple),\n            brown: this._commaSeparatedStringToUniqueList(settings.extensionConfig().default.words.brown),\n            sky: this._commaSeparatedStringToUniqueList(settings.extensionConfig().default.words.sky),\n            lime: this._commaSeparatedStringToUniqueList(settings.extensionConfig().default.words.lime),\n            green: this._commaSeparatedStringToUniqueList(settings.extensionConfig().default.words.green),\n            red: this._commaSeparatedStringToUniqueList(settings.extensionConfig().default.words.red),\n            yellow: this._commaSeparatedStringToUniqueList(settings.extensionConfig().default.words.yellow),\n        };\n\n        return { ...defaultWords, ...settings.extensionConfig().expert.custom.words.mapping };\n    }\n\n    private _getDecorationStyle(decoOptions: any) {\n        return { type: vscode.window.createTextEditorDecorationType(decoOptions), options: decoOptions };\n    }\n\n    private _getBookmarkDataUri(color: string) {\n        return vscode.Uri.parse(\n            \"data:image/svg+xml,\" +\n            encodeURIComponent(`<svg version=\"1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 48 48\" enable-background=\"new 0 0 48 48\"><path fill=\"${color}\" d=\"M37,43l-13-6l-13,6V9c0-2.2,1.8-4,4-4h18c2.2,0,4,1.8,4,4V43z\"/></svg>`)\n        );\n    }\n\n    private _getDecorationDefaultStyle(color: string) {\n        return this._getDecorationStyle({\n            \"gutterIconPath\": this._getBookmarkDataUri(color),\n            \"overviewRulerColor\": color + \"B0\",   // this is safe/suitable for the defaults only.  Custom ruler color is handled below.\n            \"light\": {\n                \"fontWeight\": \"bold\"\n            },\n            \"dark\": {\n                \"color\": color\n            }\n        })\n    }\n\n    private _reLoadDecorations(): Record<string, any> {\n        const blue = '#1874e2';\n        const green = '#10a37f';\n        const purple = '#C679E0';\n        const red = '#F44336';\n        const brown = '#cc6d2e';\n        const sky = '#03A9F4';\n        const lime = '#CDDC39';\n        const yellow = '#cdb116';\n        let styles = {\n            \"default\": this._getDecorationDefaultStyle(blue),\n            \"red\": this._getDecorationDefaultStyle(red),\n            \"blue\": this._getDecorationDefaultStyle(blue),\n            \"green\": this._getDecorationDefaultStyle(green),\n            \"purple\": this._getDecorationDefaultStyle(purple),\n            \"brown\": this._getDecorationDefaultStyle(brown),\n            \"sky\": this._getDecorationDefaultStyle(sky),\n            \"lime\": this._getDecorationDefaultStyle(lime),\n            \"yellow\": this._getDecorationDefaultStyle(yellow)\n        };\n\n        let customStyles = settings.extensionConfig().expert.custom.styles;\n\n        for (var decoId in customStyles) {\n\n            if (!customStyles.hasOwnProperty(decoId)) {\n                continue;\n            }\n\n            let decoOptions = { ...customStyles[decoId] };\n\n            // default to blue if neither an icon path nor an icon color is specified\n            if (!decoOptions.gutterIconPath) {\n                decoOptions.gutterIconColor = decoOptions.gutterIconColor || blue;\n            }\n\n            //apply icon color if provided, otherwise fix the path\n            decoOptions.gutterIconPath = decoOptions.gutterIconColor ? this._getBookmarkDataUri(decoOptions.gutterIconColor) : this.context.asAbsolutePath(decoOptions.gutterIconPath);\n\n            //overview\n            if (decoOptions.overviewRulerColor) {\n                decoOptions.overviewRulerLane = vscode.OverviewRulerLane.Full;\n            }\n            //background color\n            if (decoOptions.backgroundColor) {\n                decoOptions.isWholeLine = true;\n            }\n            styles[decoId as keyof typeof styles] = this._getDecorationStyle(decoOptions);\n        }\n\n        return styles;\n    }\n\n    public resetWorkspace() {\n        if (!this._isWorkspaceAvailable()) return; //cannot save\n        this.context.workspaceState.update(\"bookmarks.object\", \"{}\");\n        let workspaceFolder = vscode.workspace.workspaceFolders ? vscode.workspace.workspaceFolders[0].uri.fsPath : undefined;\n        fs.unlinkSync(workspaceFolder + '/.instructions/instructions.md')\n        fs.unlinkSync(workspaceFolder + '/.instructions/bookmarks.json')\n\n    }\n\n    private transformBookmarks(bookmarks: Bookmarks): TransformedData {\n        let transformedData: TransformedData = {}; // Use explicit type\n        // JAN2024: Order by file path\n        let sortedEntries = Object.entries(bookmarks).sort((a, b) => a[0].localeCompare(b[0]));\n\n        for (const [filePath, tags] of sortedEntries) {\n            let fileData: FileDataEntry[] = [];\n            for (const [tag, entries] of Object.entries(tags)) {\n                for (const entry of entries) {\n                    let tagTextSplit = entry.text.split(' ', 1);\n                    fileData.push({\n                        line: entry.range.start.line,\n                        startCharacter: entry.range.start.character,\n                        endCharacter: entry.range.end.character,\n                        tag: tagTextSplit[0].trim(),\n                        tagText: tagTextSplit.length > 1 ? tagTextSplit[1].substring(0, 50) : '',\n                    });\n                }\n            }\n\n            fileData.sort((a, b) => a.line - b.line || a.startCharacter - b.startCharacter);\n            transformedData[filePath] = fileData; // No error now\n        }\n\n        return transformedData;\n    }\n\n    private async processTags(inputJson: Record<string, any>) {\n        let output = []\n        for (const filePath of Object.keys(inputJson)) {\n            const sortedTags = inputJson[filePath]\n            try {\n                const file = await vscode.workspace.openTextDocument(vscode.Uri.parse(filePath))\n                let fileContents = file.getText()\n                let firstTag = sortedTags[0]\n                firstTag.tagStart = fileContents.indexOf(firstTag.tag)\n                firstTag.tagLineStart = firstTag.tagStart - firstTag.startCharacter\n\n                for (let i = 0; i < sortedTags.length; i++) {\n                    const tag = sortedTags[i]\n                    let tagEnd\n\n                    if (i + 1 < sortedTags.length) {\n                        const nextTag = sortedTags[i + 1]\n                        nextTag.tagStart = fileContents.indexOf(nextTag.tag, tag.tagStart + tag.tag.length)\n\n                        if (nextTag.startCharacter !== 0 && tag.line !== nextTag.line) {\n                            nextTag.tagLineStart = nextTag.tagStart - nextTag.startCharacter\n                        } else {\n                            nextTag.tagLineStart = nextTag.tagStart\n                        }\n                        tagEnd = nextTag.tagLineStart\n                    } else {\n                        tagEnd = fileContents.length\n                    }\n                    let textBeforeTag = fileContents.substring(tag.tagLineStart, tag.tagStart)\n                    let textAfterTag = fileContents.substring(tag.tagStart + tag.tag.length + 1, tagEnd)\n                    if (tag.tag.indexOf('@summarize(') == 0) {\n                        textAfterTag = fileContents.substring(tag.tagStart, tagEnd) + '@end-summarize\\n'\n                    }\n\n                    if (textAfterTag !== '' && tag.tag == '@out-file') {\n                        break //stop processing the file\n                    }\n\n                    if (textAfterTag !== '' && tag.tag !== '@out') {\n                        output.push(textBeforeTag + textAfterTag)\n                    }\n                }\n            } catch (error) {\n                console.error(error)\n            }\n        }\n        return output\n    }\n\n    public async getInstructions(): Promise<string> {\n        return (await this.processTags(this.transformBookmarks(this.bookmarks))).join('\\n');\n    }\n\n    private async saveToWorkspace(): Promise<void> {\n        if (!this._isWorkspaceAvailable()) return; //cannot save\n        this.context.workspaceState.update(\"bookmarks.object\", JSON.stringify(this.bookmarks));\n        let workspaceFolder = vscode.workspace.workspaceFolders ? vscode.workspace.workspaceFolders[0].uri.fsPath : undefined;\n        if (workspaceFolder) {\n            //check if .instructions folder exists\n            if (!fs.existsSync(workspaceFolder + '/.instructions')) {\n                fs.mkdirSync(workspaceFolder + '/.instructions');\n            }\n            fs.writeFile(workspaceFolder + '/.instructions/bookmarks.json', JSON.stringify(this.bookmarks), (err) => {\n                if (err) {\n                    console.error(err);\n                    return;\n                };\n            });\n\n            let output = await this.processTags(this.transformBookmarks(this.bookmarks));\n            fs.writeFile(workspaceFolder + '/.instructions/instructions.md', output.join('\\n'), (err) => {\n                if (err) {\n                    console.error(err);\n                    return;\n                };\n            });\n        }\n\n    }\n\n    private _isWorkspaceAvailable() {\n        //single or multi root\n        return vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length >= 1;\n    }\n\n    private deserializeBookmark(serializedBookmark: any): Bookmark {\n        const start = new vscode.Position(serializedBookmark.range[0].line, serializedBookmark.range[0].character);\n        const end = new vscode.Position(serializedBookmark.range[1].line, serializedBookmark.range[1].character);\n        const range = new vscode.Range(start, end);\n        return {\n            range: range,\n            text: serializedBookmark.text\n        };\n    }\n\n    public loadFromWorkspace(): void {\n        if (!this._isWorkspaceAvailable()) return; //cannot load\n        this.bookmarks = JSON.parse(this.context.workspaceState.get(\"bookmarks.object\", \"{}\"));\n\n\n        //remove all non existing files\n        Object.keys(this.bookmarks).forEach(filepath => {\n            const fsPath = vscode.Uri.parse(filepath).fsPath;\n            if (!fs.existsSync(fsPath) || minimatch(fsPath, this.excludePattern)) {\n                delete this.bookmarks[filepath];\n                return;\n            }\n            Object.keys(this.bookmarks[filepath]).forEach(cat => {\n                // For each category\n                this.bookmarks[filepath][cat] = this.bookmarks[filepath][cat].map((serializedBookmark: any) => {\n                    // Deserialize the serialized bookmark to a real Bookmark object\n                    return this.deserializeBookmark(serializedBookmark);\n                });\n            });\n        });\n    }\n}\n\n\nenum NodeType {\n    FILE = 1,\n    LOCATION = 2,\n}\n\ninterface TreeElement {\n    resource: vscode.Uri;\n    tooltip?: string;\n    name: string;\n    type: NodeType;\n    parent: TreeElement | null;\n    iconPath: vscode.ThemeIcon | string | undefined;\n    location?: vscode.Location | null;\n    label?: string;\n    category?: string;\n}\n\nclass InstructionsDataModel {\n    private controller: InstructionsController;\n\n    constructor(controller: InstructionsController) {\n        this.controller = controller;\n    }\n\n    getRoot(): TreeElement[] {\n        let fileBookmarks = Object.keys(this.controller.bookmarks);\n\n        if (settings.extensionConfig().view.showVisibleFilesOnly) {\n            let visibleEditorUris: string[];\n\n            if (settings.extensionConfig().view.showVisibleFilesOnlyMode === 'onlyActiveEditor') {\n                const activeEditor = vscode.window.activeTextEditor;\n                visibleEditorUris = activeEditor ? [activeEditor.document.uri.path] : [];\n            } else {\n                visibleEditorUris = vscode.window.visibleTextEditors.map((te) => te.document.uri.path);\n            }\n\n            fileBookmarks = fileBookmarks.filter((v) =>\n                visibleEditorUris.includes(vscode.Uri.parse(v).path)\n            );\n        }\n\n        return fileBookmarks.sort().map((v) => ({\n            resource: vscode.Uri.parse(v),\n            tooltip: v,\n            name: v,\n            type: NodeType.FILE,\n            parent: null,\n            iconPath: vscode.ThemeIcon.File,\n            location: null,\n            label: path.basename(vscode.Uri.parse(v).fsPath)\n        }));\n    }\n\n    getChildren(element: TreeElement): TreeElement[] {\n        if (element.type === NodeType.FILE) {\n            const extractTextAfterLastAtWord = (inputString: string): string => {\n                const zeroedRegex = /^@summarize\\([^)]*\\)\\s*/;\n                const zeroedMatch = inputString.match(zeroedRegex);\n                if (zeroedMatch) {\n                    return zeroedMatch[0].trim();\n                }\n\n                const firstRegex = /@[\\w-]+[^@]*$/;\n                const firstMatch = inputString.match(firstRegex);\n\n                if (firstMatch) {\n                    let remainingText = firstMatch[0];\n                    let secondRegex: RegExp;\n\n                    while (true) {\n                        if (remainingText.startsWith('@summarize(')) {\n                            secondRegex = /^@summarize\\([^)]*\\)\\s*/;\n                        } else {\n                            secondRegex = /^@[\\w-]+\\s+/;\n                        }\n\n                        const secondMatch = remainingText.match(secondRegex);\n\n                        if (secondMatch) {\n                            remainingText = remainingText.substring(secondMatch[0].length);\n                        } else {\n                            break;\n                        }\n                    }\n\n                    return remainingText.trim();\n                }\n\n                return '';\n            };\n\n            const bookmarks = Object.keys(this.controller.bookmarks[element.name]).flatMap((cat) => {\n                return this.controller.bookmarks[element.name][cat].map((v: any) => {\n                    const location = new vscode.Location(element.resource, v.range);\n                    return {\n                        resource: element.resource,\n                        location: location,\n                        label: extractTextAfterLastAtWord(v.text),\n                        name: v.text.trim(),\n                        type: NodeType.LOCATION,\n                        category: cat,\n                        parent: element,\n                        iconPath: this.controller.styles[cat]?.options?.gutterIconPath,\n                    };\n                });\n            });\n\n            return bookmarks.sort((a, b) => a.location!.range.start.line - b.location!.range.start.line);\n        }\n\n        return [];\n    }\n\n    getNeighbors(element: TreeElement): { previous: TreeElement | null; next: TreeElement | null } {\n        const ret: { previous: TreeElement | null; next: TreeElement | null } = { previous: null, next: null };\n        let parent = element.parent;\n\n        if (!parent) {\n            parent = { ...element, type: NodeType.FILE, name: element.resource.toString() } as TreeElement;\n        }\n\n        const bookmarks = this.getChildren(parent);\n\n        let gotElement = false;\n\n        for (const b of bookmarks) {\n            if (!gotElement && JSON.stringify(b.location) === JSON.stringify(element.location)) {\n                gotElement = true;\n                continue;\n            }\n\n            if (!gotElement) {\n                ret.previous = b;\n            } else {\n                ret.next = b;\n                break;\n            }\n        }\n\n        return ret;\n    }\n}\n\n\nclass InlineBookmarkTreeDataProvider implements vscode.TreeDataProvider<TreeElement> {\n    private _onDidChangeTreeData: vscode.EventEmitter<TreeElement | undefined | null | void> = new vscode.EventEmitter<TreeElement | undefined | null | void>();\n    readonly onDidChangeTreeData: vscode.Event<TreeElement | undefined | null | void> = this._onDidChangeTreeData.event;\n\n    private controller: any; // Replace `any` with the actual type of your instructionsController\n    public model: InstructionsDataModel;\n    private filterTreeViewWords: string[];\n    private gitIgnoreHandler: { filter: (resource: vscode.Uri) => boolean } | undefined;\n\n    constructor(instructionsController: any) {\n        this.controller = instructionsController;\n        this.model = new InstructionsDataModel(instructionsController);\n        this.filterTreeViewWords = [];\n        this.gitIgnoreHandler = undefined;\n    }\n\n    /** TreeDataProvider Methods */\n\n    public getChildren(element?: TreeElement): Thenable<TreeElement[]> {\n        const elements = element ? this.model.getChildren(element) : this.model.getRoot();\n        return Promise.resolve(this._filterTreeView(elements));\n    }\n\n    getParent(element: TreeElement): TreeElement | null {\n        return element.parent || null;\n    }\n\n    getTreeItem(element: TreeElement): vscode.TreeItem {\n        let label = this._formatLabel(element.label)\n        if (label == undefined) {\n            label = \"\"\n        }\n        const item = new vscode.TreeItem(\n            label, // Pass a valid label\n            element.type === NodeType.LOCATION\n                ? vscode.TreeItemCollapsibleState.None\n                : settings.extensionConfig().view.expanded\n                    ? vscode.TreeItemCollapsibleState.Expanded\n                    : vscode.TreeItemCollapsibleState.Collapsed\n        );\n\n        item.id =\n            element.type === NodeType.LOCATION && element.location\n                ? this._getId(element.location)\n                : this._getId(element.resource);\n\n        item.resourceUri = element.resource;\n        item.iconPath = element.iconPath;\n        item.command =\n            element.type === NodeType.LOCATION && element.location\n                ? {\n                    command: \"instructions-manager.jumpToRange\",\n                    arguments: [element.location.uri, element.location.range],\n                    title: \"JumpTo\",\n                }\n                : undefined;\n\n        return item;\n    }\n\n    /** Utility Methods */\n\n    private _getId(o: vscode.Location | vscode.Uri): string {\n        return crypto.createHash('sha1').update(JSON.stringify(o)).digest('hex');\n    }\n\n    private _formatLabel(label?: string): string | undefined {\n        if (!settings.extensionConfig().view.words.hide || !label) {\n            return label;\n        }\n        const words = Object.values(this.controller.words).flat() as string[];\n        return words.reduce((prevs, word) => prevs.replace(new RegExp(word, 'g'), ''), label);\n    }\n\n    private _filterTreeView(elements: TreeElement[]): TreeElement[] {\n        if (this.gitIgnoreHandler?.filter) {\n            elements = elements.filter((e) => this.gitIgnoreHandler!.filter(e.resource));\n        }\n\n        if (this.filterTreeViewWords.length) {\n            elements = elements.filter((e) =>\n                this.filterTreeViewWords.some((rx) => new RegExp(rx, 'g').test(e.label || ''))\n            );\n        }\n\n        return elements;\n    }\n\n    /** Public Methods */\n\n    setTreeViewFilterWords(words: string[]): void {\n        this.filterTreeViewWords = words;\n    }\n\n    setTreeViewGitIgnoreHandler(gi: { filter: (resource: vscode.Uri) => boolean }): void {\n        this.gitIgnoreHandler = gi;\n    }\n\n    refresh(): void {\n        this._onDidChangeTreeData.fire();\n    }\n}\n\n\n\nexport { TreeElement, InstructionsController, InlineBookmarkTreeDataProvider, NodeType };", "import expand from 'brace-expansion'\nimport { assertValidPattern } from './assert-valid-pattern.js'\nimport { AST, ExtglobType } from './ast.js'\nimport { escape } from './escape.js'\nimport { unescape } from './unescape.js'\n\ntype Platform =\n  | 'aix'\n  | 'android'\n  | 'darwin'\n  | 'freebsd'\n  | 'haiku'\n  | 'linux'\n  | 'openbsd'\n  | 'sunos'\n  | 'win32'\n  | 'cygwin'\n  | 'netbsd'\n\nexport interface MinimatchOptions {\n  nobrace?: boolean\n  nocomment?: boolean\n  nonegate?: boolean\n  debug?: boolean\n  noglobstar?: boolean\n  noext?: boolean\n  nonull?: boolean\n  windowsPathsNoEscape?: boolean\n  allowWindowsEscape?: boolean\n  partial?: boolean\n  dot?: boolean\n  nocase?: boolean\n  nocaseMagicOnly?: boolean\n  magicalBraces?: boolean\n  matchBase?: boolean\n  flipNegate?: boolean\n  preserveMultipleSlashes?: boolean\n  optimizationLevel?: number\n  platform?: Platform\n  windowsNoMagicRoot?: boolean\n}\n\nexport const minimatch = (\n  p: string,\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/\nconst starDotExtTest = (ext: string) => (f: string) =>\n  !f.startsWith('.') && f.endsWith(ext)\nconst starDotExtTestDot = (ext: string) => (f: string) => f.endsWith(ext)\nconst starDotExtTestNocase = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => !f.startsWith('.') && f.toLowerCase().endsWith(ext)\n}\nconst starDotExtTestNocaseDot = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => f.toLowerCase().endsWith(ext)\n}\nconst starDotStarRE = /^\\*+\\.\\*+$/\nconst starDotStarTest = (f: string) => !f.startsWith('.') && f.includes('.')\nconst starDotStarTestDot = (f: string) =>\n  f !== '.' && f !== '..' && f.includes('.')\nconst dotStarRE = /^\\.\\*+$/\nconst dotStarTest = (f: string) => f !== '.' && f !== '..' && f.startsWith('.')\nconst starRE = /^\\*+$/\nconst starTest = (f: string) => f.length !== 0 && !f.startsWith('.')\nconst starTestDot = (f: string) => f.length !== 0 && f !== '.' && f !== '..'\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/\nconst qmarksTestNocase = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestNocaseDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTest = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTestNoExt = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && !f.startsWith('.')\n}\nconst qmarksTestNoExtDot = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && f !== '.' && f !== '..'\n}\n\n/* c8 ignore start */\nconst defaultPlatform: Platform = (\n  typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n      process.platform\n    : 'posix'\n) as Platform\ntype Sep = '\\\\' | '/'\nconst path: { [k: string]: { sep: Sep } } = {\n  win32: { sep: '\\\\' },\n  posix: { sep: '/' },\n}\n/* c8 ignore stop */\n\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep\nminimatch.sep = sep\n\nexport const GLOBSTAR = Symbol('globstar **')\nminimatch.GLOBSTAR = GLOBSTAR\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?'\n\nexport const filter =\n  (pattern: string, options: MinimatchOptions = {}) =>\n  (p: string) =>\n    minimatch(p, pattern, options)\nminimatch.filter = filter\n\nconst ext = (a: MinimatchOptions, b: MinimatchOptions = {}) =>\n  Object.assign({}, a, b)\n\nexport const defaults = (def: MinimatchOptions): typeof minimatch => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = (p: string, pattern: string, options: MinimatchOptions = {}) =>\n    orig(p, pattern, ext(def, options))\n\n  return Object.assign(m, {\n    Minimatch: class Minimatch extends orig.Minimatch {\n      constructor(pattern: string, options: MinimatchOptions = {}) {\n        super(pattern, ext(def, options))\n      }\n      static defaults(options: MinimatchOptions) {\n        return orig.defaults(ext(def, options)).Minimatch\n      }\n    },\n\n    AST: class AST extends orig.AST {\n      /* c8 ignore start */\n      constructor(\n        type: ExtglobType | null,\n        parent?: AST,\n        options: MinimatchOptions = {}\n      ) {\n        super(type, parent, ext(def, options))\n      }\n      /* c8 ignore stop */\n\n      static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n        return orig.AST.fromGlob(pattern, ext(def, options))\n      }\n    },\n\n    unescape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.unescape(s, ext(def, options)),\n\n    escape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.escape(s, ext(def, options)),\n\n    filter: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.filter(pattern, ext(def, options)),\n\n    defaults: (options: MinimatchOptions) => orig.defaults(ext(def, options)),\n\n    makeRe: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.makeRe(pattern, ext(def, options)),\n\n    braceExpand: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.braceExpand(pattern, ext(def, options)),\n\n    match: (list: string[], pattern: string, options: MinimatchOptions = {}) =>\n      orig.match(list, pattern, ext(def, options)),\n\n    sep: orig.sep,\n    GLOBSTAR: GLOBSTAR as typeof GLOBSTAR,\n  })\n}\nminimatch.defaults = defaults\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\nminimatch.braceExpand = braceExpand\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\n\nexport const makeRe = (pattern: string, options: MinimatchOptions = {}) =>\n  new Minimatch(pattern, options).makeRe()\nminimatch.makeRe = makeRe\n\nexport const match = (\n  list: string[],\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(f => mm.match(f))\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\nminimatch.match = match\n\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\nexport type MMRegExp = RegExp & {\n  _src?: string\n  _glob?: string\n}\n\nexport type ParseReturnFiltered = string | MMRegExp | typeof GLOBSTAR\nexport type ParseReturn = ParseReturnFiltered | false\n\nexport class Minimatch {\n  options: MinimatchOptions\n  set: ParseReturnFiltered[][]\n  pattern: string\n\n  windowsPathsNoEscape: boolean\n  nonegate: boolean\n  negate: boolean\n  comment: boolean\n  empty: boolean\n  preserveMultipleSlashes: boolean\n  partial: boolean\n  globSet: string[]\n  globParts: string[][]\n  nocase: boolean\n\n  isWindows: boolean\n  platform: Platform\n  windowsNoMagicRoot: boolean\n\n  regexp: false | null | MMRegExp\n  constructor(pattern: string, options: MinimatchOptions = {}) {\n    assertValidPattern(pattern)\n\n    options = options || {}\n    this.options = options\n    this.pattern = pattern\n    this.platform = options.platform || defaultPlatform\n    this.isWindows = this.platform === 'win32'\n    this.windowsPathsNoEscape =\n      !!options.windowsPathsNoEscape || options.allowWindowsEscape === false\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/')\n    }\n    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes\n    this.regexp = null\n    this.negate = false\n    this.nonegate = !!options.nonegate\n    this.comment = false\n    this.empty = false\n    this.partial = !!options.partial\n    this.nocase = !!this.options.nocase\n    this.windowsNoMagicRoot =\n      options.windowsNoMagicRoot !== undefined\n        ? options.windowsNoMagicRoot\n        : !!(this.isWindows && this.nocase)\n\n    this.globSet = []\n    this.globParts = []\n    this.set = []\n\n    // make the set of regexps etc.\n    this.make()\n  }\n\n  hasMagic(): boolean {\n    if (this.options.magicalBraces && this.set.length > 1) {\n      return true\n    }\n    for (const pattern of this.set) {\n      for (const part of pattern) {\n        if (typeof part !== 'string') return true\n      }\n    }\n    return false\n  }\n\n  debug(..._: any[]) {}\n\n  make() {\n    const pattern = this.pattern\n    const options = this.options\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true\n      return\n    }\n\n    if (!pattern) {\n      this.empty = true\n      return\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate()\n\n    // step 2: expand braces\n    this.globSet = [...new Set(this.braceExpand())]\n\n    if (options.debug) {\n      this.debug = (...args: any[]) => console.error(...args)\n    }\n\n    this.debug(this.pattern, this.globSet)\n\n    // step 3: now we have a set, so turn each one into a series of\n    // path-portion matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    //\n    // First, we preprocess to make the glob pattern sets a bit simpler\n    // and deduped.  There are some perf-killing patterns that can cause\n    // problems with a glob walk, but we can simplify them down a bit.\n    const rawGlobParts = this.globSet.map(s => this.slashSplit(s))\n    this.globParts = this.preprocess(rawGlobParts)\n    this.debug(this.pattern, this.globParts)\n\n    // glob --> regexps\n    let set = this.globParts.map((s, _, __) => {\n      if (this.isWindows && this.windowsNoMagicRoot) {\n        // check if it's a drive or unc path.\n        const isUNC =\n          s[0] === '' &&\n          s[1] === '' &&\n          (s[2] === '?' || !globMagic.test(s[2])) &&\n          !globMagic.test(s[3])\n        const isDrive = /^[a-z]:/i.test(s[0])\n        if (isUNC) {\n          return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))]\n        } else if (isDrive) {\n          return [s[0], ...s.slice(1).map(ss => this.parse(ss))]\n        }\n      }\n      return s.map(ss => this.parse(ss))\n    })\n\n    this.debug(this.pattern, set)\n\n    // filter out everything that didn't compile properly.\n    this.set = set.filter(\n      s => s.indexOf(false) === -1\n    ) as ParseReturnFiltered[][]\n\n    // do not treat the ? in UNC paths as magic\n    if (this.isWindows) {\n      for (let i = 0; i < this.set.length; i++) {\n        const p = this.set[i]\n        if (\n          p[0] === '' &&\n          p[1] === '' &&\n          this.globParts[i][2] === '?' &&\n          typeof p[3] === 'string' &&\n          /^[a-z]:$/i.test(p[3])\n        ) {\n          p[2] = '?'\n        }\n      }\n    }\n\n    this.debug(this.pattern, this.set)\n  }\n\n  // various transforms to equivalent pattern sets that are\n  // faster to process in a filesystem walk.  The goal is to\n  // eliminate what we can, and push all ** patterns as far\n  // to the right as possible, even if it increases the number\n  // of patterns that we have to process.\n  preprocess(globParts: string[][]) {\n    // if we're not in globstar mode, then turn all ** into *\n    if (this.options.noglobstar) {\n      for (let i = 0; i < globParts.length; i++) {\n        for (let j = 0; j < globParts[i].length; j++) {\n          if (globParts[i][j] === '**') {\n            globParts[i][j] = '*'\n          }\n        }\n      }\n    }\n\n    const { optimizationLevel = 1 } = this.options\n\n    if (optimizationLevel >= 2) {\n      // aggressive optimization for the purpose of fs walking\n      globParts = this.firstPhasePreProcess(globParts)\n      globParts = this.secondPhasePreProcess(globParts)\n    } else if (optimizationLevel >= 1) {\n      // just basic optimizations to remove some .. parts\n      globParts = this.levelOneOptimize(globParts)\n    } else {\n      // just collapse multiple ** portions into one\n      globParts = this.adjascentGlobstarOptimize(globParts)\n    }\n\n    return globParts\n  }\n\n  // just get rid of adjascent ** portions\n  adjascentGlobstarOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      let gs: number = -1\n      while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n        let i = gs\n        while (parts[i + 1] === '**') {\n          i++\n        }\n        if (i !== gs) {\n          parts.splice(gs, i - gs)\n        }\n      }\n      return parts\n    })\n  }\n\n  // get rid of adjascent ** and resolve .. portions\n  levelOneOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      parts = parts.reduce((set: string[], part) => {\n        const prev = set[set.length - 1]\n        if (part === '**' && prev === '**') {\n          return set\n        }\n        if (part === '..') {\n          if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n            set.pop()\n            return set\n          }\n        }\n        set.push(part)\n        return set\n      }, [])\n      return parts.length === 0 ? [''] : parts\n    })\n  }\n\n  levelTwoFileOptimize(parts: string | string[]) {\n    if (!Array.isArray(parts)) {\n      parts = this.slashSplit(parts)\n    }\n    let didSomething: boolean = false\n    do {\n      didSomething = false\n      // <pre>/<e>/<rest> -> <pre>/<rest>\n      if (!this.preserveMultipleSlashes) {\n        for (let i = 1; i < parts.length - 1; i++) {\n          const p = parts[i]\n          // don't squeeze out UNC patterns\n          if (i === 1 && p === '' && parts[0] === '') continue\n          if (p === '.' || p === '') {\n            didSomething = true\n            parts.splice(i, 1)\n            i--\n          }\n        }\n        if (\n          parts[0] === '.' &&\n          parts.length === 2 &&\n          (parts[1] === '.' || parts[1] === '')\n        ) {\n          didSomething = true\n          parts.pop()\n        }\n      }\n\n      // <pre>/<p>/../<rest> -> <pre>/<rest>\n      let dd: number = 0\n      while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n        const p = parts[dd - 1]\n        if (p && p !== '.' && p !== '..' && p !== '**') {\n          didSomething = true\n          parts.splice(dd - 1, 2)\n          dd -= 2\n        }\n      }\n    } while (didSomething)\n    return parts.length === 0 ? [''] : parts\n  }\n\n  // First phase: single-pattern processing\n  // <pre> is 1 or more portions\n  // <rest> is 1 or more portions\n  // <p> is any portion other than ., .., '', or **\n  // <e> is . or ''\n  //\n  // **/.. is *brutal* for filesystem walking performance, because\n  // it effectively resets the recursive walk each time it occurs,\n  // and ** cannot be reduced out by a .. pattern part like a regexp\n  // or most strings (other than .., ., and '') can be.\n  //\n  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n  // <pre>/<e>/<rest> -> <pre>/<rest>\n  // <pre>/<p>/../<rest> -> <pre>/<rest>\n  // **/**/<rest> -> **/<rest>\n  //\n  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n  // this WOULD be allowed if ** did follow symlinks, or * didn't\n  firstPhasePreProcess(globParts: string[][]) {\n    let didSomething = false\n    do {\n      didSomething = false\n      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n      for (let parts of globParts) {\n        let gs: number = -1\n        while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n          let gss: number = gs\n          while (parts[gss + 1] === '**') {\n            // <pre>/**/**/<rest> -> <pre>/**/<rest>\n            gss++\n          }\n          // eg, if gs is 2 and gss is 4, that means we have 3 **\n          // parts, and can remove 2 of them.\n          if (gss > gs) {\n            parts.splice(gs + 1, gss - gs)\n          }\n\n          let next = parts[gs + 1]\n          const p = parts[gs + 2]\n          const p2 = parts[gs + 3]\n          if (next !== '..') continue\n          if (\n            !p ||\n            p === '.' ||\n            p === '..' ||\n            !p2 ||\n            p2 === '.' ||\n            p2 === '..'\n          ) {\n            continue\n          }\n          didSomething = true\n          // edit parts in place, and push the new one\n          parts.splice(gs, 1)\n          const other = parts.slice(0)\n          other[gs] = '**'\n          globParts.push(other)\n          gs--\n        }\n\n        // <pre>/<e>/<rest> -> <pre>/<rest>\n        if (!this.preserveMultipleSlashes) {\n          for (let i = 1; i < parts.length - 1; i++) {\n            const p = parts[i]\n            // don't squeeze out UNC patterns\n            if (i === 1 && p === '' && parts[0] === '') continue\n            if (p === '.' || p === '') {\n              didSomething = true\n              parts.splice(i, 1)\n              i--\n            }\n          }\n          if (\n            parts[0] === '.' &&\n            parts.length === 2 &&\n            (parts[1] === '.' || parts[1] === '')\n          ) {\n            didSomething = true\n            parts.pop()\n          }\n        }\n\n        // <pre>/<p>/../<rest> -> <pre>/<rest>\n        let dd: number = 0\n        while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n          const p = parts[dd - 1]\n          if (p && p !== '.' && p !== '..' && p !== '**') {\n            didSomething = true\n            const needDot = dd === 1 && parts[dd + 1] === '**'\n            const splin = needDot ? ['.'] : []\n            parts.splice(dd - 1, 2, ...splin)\n            if (parts.length === 0) parts.push('')\n            dd -= 2\n          }\n        }\n      }\n    } while (didSomething)\n\n    return globParts\n  }\n\n  // second phase: multi-pattern dedupes\n  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n  //\n  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n  // ^-- not valid because ** doens't follow symlinks\n  secondPhasePreProcess(globParts: string[][]): string[][] {\n    for (let i = 0; i < globParts.length - 1; i++) {\n      for (let j = i + 1; j < globParts.length; j++) {\n        const matched = this.partsMatch(\n          globParts[i],\n          globParts[j],\n          !this.preserveMultipleSlashes\n        )\n        if (matched) {\n          globParts[i] = []\n          globParts[j] = matched\n          break\n        }\n      }\n    }\n    return globParts.filter(gs => gs.length)\n  }\n\n  partsMatch(\n    a: string[],\n    b: string[],\n    emptyGSMatch: boolean = false\n  ): false | string[] {\n    let ai = 0\n    let bi = 0\n    let result: string[] = []\n    let which: string = ''\n    while (ai < a.length && bi < b.length) {\n      if (a[ai] === b[bi]) {\n        result.push(which === 'b' ? b[bi] : a[ai])\n        ai++\n        bi++\n      } else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n        result.push(a[ai])\n        ai++\n      } else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n        result.push(b[bi])\n        bi++\n      } else if (\n        a[ai] === '*' &&\n        b[bi] &&\n        (this.options.dot || !b[bi].startsWith('.')) &&\n        b[bi] !== '**'\n      ) {\n        if (which === 'b') return false\n        which = 'a'\n        result.push(a[ai])\n        ai++\n        bi++\n      } else if (\n        b[bi] === '*' &&\n        a[ai] &&\n        (this.options.dot || !a[ai].startsWith('.')) &&\n        a[ai] !== '**'\n      ) {\n        if (which === 'a') return false\n        which = 'b'\n        result.push(b[bi])\n        ai++\n        bi++\n      } else {\n        return false\n      }\n    }\n    // if we fall out of the loop, it means they two are identical\n    // as long as their lengths match\n    return a.length === b.length && result\n  }\n\n  parseNegate() {\n    if (this.nonegate) return\n\n    const pattern = this.pattern\n    let negate = false\n    let negateOffset = 0\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate\n      negateOffset++\n    }\n\n    if (negateOffset) this.pattern = pattern.slice(negateOffset)\n    this.negate = negate\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(file: string[], pattern: ParseReturn[], partial: boolean = false) {\n    const options = this.options\n\n    // UNC paths like //?/X:/... can match X:/... and vice versa\n    // Drive letters in absolute drive or unc paths are always compared\n    // case-insensitively.\n    if (this.isWindows) {\n      const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0])\n      const fileUNC =\n        !fileDrive &&\n        file[0] === '' &&\n        file[1] === '' &&\n        file[2] === '?' &&\n        /^[a-z]:$/i.test(file[3])\n\n      const patternDrive =\n        typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0])\n      const patternUNC =\n        !patternDrive &&\n        pattern[0] === '' &&\n        pattern[1] === '' &&\n        pattern[2] === '?' &&\n        typeof pattern[3] === 'string' &&\n        /^[a-z]:$/i.test(pattern[3])\n\n      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined\n      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined\n      if (typeof fdi === 'number' && typeof pdi === 'number') {\n        const [fd, pd]: [string, string] = [file[fdi], pattern[pdi] as string]\n        if (fd.toLowerCase() === pd.toLowerCase()) {\n          pattern[pdi] = fd\n          if (pdi > fdi) {\n            pattern = pattern.slice(pdi)\n          } else if (fdi > pdi) {\n            file = file.slice(fdi)\n          }\n        }\n      }\n    }\n\n    // resolve and reduce . and .. portions in the file as well.\n    // dont' need to do the second phase, because it's only one string[]\n    const { optimizationLevel = 1 } = this.options\n    if (optimizationLevel >= 2) {\n      file = this.levelTwoFileOptimize(file)\n    }\n\n    this.debug('matchOne', this, { file, pattern })\n    this.debug('matchOne', file.length, pattern.length)\n\n    for (\n      var fi = 0, pi = 0, fl = file.length, pl = pattern.length;\n      fi < fl && pi < pl;\n      fi++, pi++\n    ) {\n      this.debug('matchOne loop')\n      var p = pattern[pi]\n      var f = file[fi]\n\n      this.debug(pattern, p, f)\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* c8 ignore start */\n      if (p === false) {\n        return false\n      }\n      /* c8 ignore stop */\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f])\n\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi\n        var pr = pi + 1\n        if (pr === pl) {\n          this.debug('** at the end')\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (\n              file[fi] === '.' ||\n              file[fi] === '..' ||\n              (!options.dot && file[fi].charAt(0) === '.')\n            )\n              return false\n          }\n          return true\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr]\n\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee)\n            // found a match.\n            return true\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (\n              swallowee === '.' ||\n              swallowee === '..' ||\n              (!options.dot && swallowee.charAt(0) === '.')\n            ) {\n              this.debug('dot detected!', file, fr, pattern, pr)\n              break\n            }\n\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue')\n            fr++\n          }\n        }\n\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        /* c8 ignore start */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n          if (fr === fl) {\n            return true\n          }\n        }\n        /* c8 ignore stop */\n        return false\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      let hit: boolean\n      if (typeof p === 'string') {\n        hit = f === p\n        this.debug('string match', p, f, hit)\n      } else {\n        hit = p.test(f)\n        this.debug('pattern match', p, f, hit)\n      }\n\n      if (!hit) return false\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === ''\n\n      /* c8 ignore start */\n    } else {\n      // should be unreachable.\n      throw new Error('wtf?')\n    }\n    /* c8 ignore stop */\n  }\n\n  braceExpand() {\n    return braceExpand(this.pattern, this.options)\n  }\n\n  parse(pattern: string): ParseReturn {\n    assertValidPattern(pattern)\n\n    const options = this.options\n\n    // shortcuts\n    if (pattern === '**') return GLOBSTAR\n    if (pattern === '') return ''\n\n    // far and away, the most common glob pattern parts are\n    // *, *.*, and *.<ext>  Add a fast check method for those.\n    let m: RegExpMatchArray | null\n    let fastTest: null | ((f: string) => boolean) = null\n    if ((m = pattern.match(starRE))) {\n      fastTest = options.dot ? starTestDot : starTest\n    } else if ((m = pattern.match(starDotExtRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? starDotExtTestNocaseDot\n            : starDotExtTestNocase\n          : options.dot\n          ? starDotExtTestDot\n          : starDotExtTest\n      )(m[1])\n    } else if ((m = pattern.match(qmarksRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? qmarksTestNocaseDot\n            : qmarksTestNocase\n          : options.dot\n          ? qmarksTestDot\n          : qmarksTest\n      )(m)\n    } else if ((m = pattern.match(starDotStarRE))) {\n      fastTest = options.dot ? starDotStarTestDot : starDotStarTest\n    } else if ((m = pattern.match(dotStarRE))) {\n      fastTest = dotStarTest\n    }\n\n    const re = AST.fromGlob(pattern, this.options).toMMPattern()\n    if (fastTest && typeof re === 'object') {\n      // Avoids overriding in frozen environments\n      Reflect.defineProperty(re, 'test', { value: fastTest })\n    }\n    return re\n  }\n\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set\n\n    if (!set.length) {\n      this.regexp = false\n      return this.regexp\n    }\n    const options = this.options\n\n    const twoStar = options.noglobstar\n      ? star\n      : options.dot\n      ? twoStarDot\n      : twoStarNoDot\n    const flags = new Set(options.nocase ? ['i'] : [])\n\n    // regexpify non-globstar patterns\n    // if ** is only item, then we just do one twoStar\n    // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if ** is last, append (\\/twoStar|) to previous\n    // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set\n      .map(pattern => {\n        const pp: (string | typeof GLOBSTAR)[] = pattern.map(p => {\n          if (p instanceof RegExp) {\n            for (const f of p.flags.split('')) flags.add(f)\n          }\n          return typeof p === 'string'\n            ? regExpEscape(p)\n            : p === GLOBSTAR\n            ? GLOBSTAR\n            : p._src\n        }) as (string | typeof GLOBSTAR)[]\n        pp.forEach((p, i) => {\n          const next = pp[i + 1]\n          const prev = pp[i - 1]\n          if (p !== GLOBSTAR || prev === GLOBSTAR) {\n            return\n          }\n          if (prev === undefined) {\n            if (next !== undefined && next !== GLOBSTAR) {\n              pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next\n            } else {\n              pp[i] = twoStar\n            }\n          } else if (next === undefined) {\n            pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?'\n          } else if (next !== GLOBSTAR) {\n            pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next\n            pp[i + 1] = GLOBSTAR\n          }\n        })\n        return pp.filter(p => p !== GLOBSTAR).join('/')\n      })\n      .join('|')\n\n    // need to wrap in parens if we had more than one thing with |,\n    // otherwise only the first will be anchored to ^ and the last to $\n    const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', '']\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^' + open + re + close + '$'\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').+$'\n\n    try {\n      this.regexp = new RegExp(re, [...flags].join(''))\n      /* c8 ignore start */\n    } catch (ex) {\n      // should be impossible\n      this.regexp = false\n    }\n    /* c8 ignore stop */\n    return this.regexp\n  }\n\n  slashSplit(p: string) {\n    // if p starts with // on windows, we preserve that\n    // so that UNC paths aren't broken.  Otherwise, any number of\n    // / characters are coalesced into one, unless\n    // preserveMultipleSlashes is set to true.\n    if (this.preserveMultipleSlashes) {\n      return p.split('/')\n    } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n      // add an extra '' for the one we lose\n      return ['', ...p.split(/\\/+/)]\n    } else {\n      return p.split(/\\/+/)\n    }\n  }\n\n  match(f: string, partial = this.partial) {\n    this.debug('match', f, this.pattern)\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) {\n      return false\n    }\n    if (this.empty) {\n      return f === ''\n    }\n\n    if (f === '/' && partial) {\n      return true\n    }\n\n    const options = this.options\n\n    // windows: need to use /, not \\\n    if (this.isWindows) {\n      f = f.split('\\\\').join('/')\n    }\n\n    // treat the test path as a set of pathparts.\n    const ff = this.slashSplit(f)\n    this.debug(this.pattern, 'split', ff)\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set\n    this.debug(this.pattern, 'set', set)\n\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename: string = ff[ff.length - 1]\n    if (!filename) {\n      for (let i = ff.length - 2; !filename && i >= 0; i--) {\n        filename = ff[i]\n      }\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i]\n      let file = ff\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename]\n      }\n      const hit = this.matchOne(file, pattern, partial)\n      if (hit) {\n        if (options.flipNegate) {\n          return true\n        }\n        return !this.negate\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) {\n      return false\n    }\n    return this.negate\n  }\n\n  static defaults(def: MinimatchOptions) {\n    return minimatch.defaults(def).Minimatch\n  }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js'\nexport { escape } from './escape.js'\nexport { unescape } from './unescape.js'\n/* c8 ignore stop */\nminimatch.AST = AST\nminimatch.Minimatch = Minimatch\nminimatch.escape = escape\nminimatch.unescape = unescape\n", "const MAX_PATTERN_LENGTH = 1024 * 64\nexport const assertValidPattern: (pattern: any) => void = (\n  pattern: any\n): asserts pattern is string => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n", "// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses: { [k: string]: [e: string, u: boolean, n?: boolean] } = {\n  '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n  '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n  '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n  '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n  '[:cntrl:]': ['\\\\p{Cc}', true],\n  '[:digit:]': ['\\\\p{Nd}', true],\n  '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n  '[:lower:]': ['\\\\p{Ll}', true],\n  '[:print:]': ['\\\\p{C}', true],\n  '[:punct:]': ['\\\\p{P}', true],\n  '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n  '[:upper:]': ['\\\\p{Lu}', true],\n  '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n  '[:xdigit:]': ['A-Fa-f0-9', false],\n}\n\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s: string) => s.replace(/[[\\]\\\\-]/g, '\\\\$&')\n// escape all regexp magic characters\nconst regexpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges: string[]): string => ranges.join('')\n\nexport type ParseClassResult = [\n  src: string,\n  uFlag: boolean,\n  consumed: number,\n  hasMagic: boolean\n]\n\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (\n  glob: string,\n  position: number\n): ParseClassResult => {\n  const pos = position\n  /* c8 ignore start */\n  if (glob.charAt(pos) !== '[') {\n    throw new Error('not in a brace expression')\n  }\n  /* c8 ignore stop */\n  const ranges: string[] = []\n  const negs: string[] = []\n\n  let i = pos + 1\n  let sawStart = false\n  let uflag = false\n  let escaping = false\n  let negate = false\n  let endPos = pos\n  let rangeStart = ''\n  WHILE: while (i < glob.length) {\n    const c = glob.charAt(i)\n    if ((c === '!' || c === '^') && i === pos + 1) {\n      negate = true\n      i++\n      continue\n    }\n\n    if (c === ']' && sawStart && !escaping) {\n      endPos = i + 1\n      break\n    }\n\n    sawStart = true\n    if (c === '\\\\') {\n      if (!escaping) {\n        escaping = true\n        i++\n        continue\n      }\n      // escaped \\ char, fall through and treat like normal char\n    }\n    if (c === '[' && !escaping) {\n      // either a posix class, a collation equivalent, or just a [\n      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n        if (glob.startsWith(cls, i)) {\n          // invalid, [a-[] is fine, but not [a-[:alpha]]\n          if (rangeStart) {\n            return ['$.', false, glob.length - pos, true]\n          }\n          i += cls.length\n          if (neg) negs.push(unip)\n          else ranges.push(unip)\n          uflag = uflag || u\n          continue WHILE\n        }\n      }\n    }\n\n    // now it's just a normal character, effectively\n    escaping = false\n    if (rangeStart) {\n      // throw this range away if it's not valid, but others\n      // can still match.\n      if (c > rangeStart) {\n        ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c))\n      } else if (c === rangeStart) {\n        ranges.push(braceEscape(c))\n      }\n      rangeStart = ''\n      i++\n      continue\n    }\n\n    // now might be the start of a range.\n    // can be either c-d or c-] or c<more...>] or c] at this point\n    if (glob.startsWith('-]', i + 1)) {\n      ranges.push(braceEscape(c + '-'))\n      i += 2\n      continue\n    }\n    if (glob.startsWith('-', i + 1)) {\n      rangeStart = c\n      i += 2\n      continue\n    }\n\n    // not the start of a range, just a single character\n    ranges.push(braceEscape(c))\n    i++\n  }\n\n  if (endPos < i) {\n    // didn't see the end of the class, not a valid class,\n    // but might still be valid as a literal match.\n    return ['', false, 0, false]\n  }\n\n  // if we got no ranges and no negates, then we have a range that\n  // cannot possibly match anything, and that poisons the whole glob\n  if (!ranges.length && !negs.length) {\n    return ['$.', false, glob.length - pos, true]\n  }\n\n  // if we got one positive range, and it's a single character, then that's\n  // not actually a magic pattern, it's just that one literal character.\n  // we should not treat that as \"magic\", we should just return the literal\n  // character. [_] is a perfectly valid way to escape glob magic chars.\n  if (\n    negs.length === 0 &&\n    ranges.length === 1 &&\n    /^\\\\?.$/.test(ranges[0]) &&\n    !negate\n  ) {\n    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0]\n    return [regexpEscape(r), false, endPos - pos, false]\n  }\n\n  const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']'\n  const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']'\n  const comb =\n    ranges.length && negs.length\n      ? '(' + sranges + '|' + snegs + ')'\n      : ranges.length\n      ? sranges\n      : snegs\n\n  return [comb, uflag, endPos - pos, true]\n}\n", "import { MinimatchOptions } from './index.js'\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nexport const unescape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  return windowsPathsNoEscape\n    ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n    : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1')\n}\n", "// parse a single path portion\n\nimport { parseClass } from './brace-expressions.js'\nimport { MinimatchOptions, MMRegExp } from './index.js'\nimport { unescape } from './unescape.js'\n\n// classes [] are handled by the parseClass method\n// for positive extglobs, we sub-parse the contents, and combine,\n// with the appropriate regexp close.\n// for negative extglobs, we sub-parse the contents, but then\n// have to include the rest of the pattern, then the parent, etc.,\n// as the thing that cannot be because RegExp negative lookaheads\n// are different from globs.\n//\n// So for example:\n// a@(i|w!(x|y)z|j)b => ^a(i|w((!?(x|y)zb).*)z|j)b$\n//   1   2 3   4 5 6      1   2    3   46      5 6\n//\n// Assembling the extglob requires not just the negated patterns themselves,\n// but also anything following the negative patterns up to the boundary\n// of the current pattern, plus anything following in the parent pattern.\n//\n//\n// So, first, we parse the string into an AST of extglobs, without turning\n// anything into regexps yet.\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y']}, 'z'], ['j']]}, 'b']\n//\n// Then, for all the negative extglobs, we append whatever comes after in\n// each parent as their tail\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y'], 'z', 'b'}, 'z'], ['j']]}, 'b']\n//\n// Lastly, we turn each of these pieces into a regexp, and join\n//\n//                                 v----- .* because there's more following,\n//                                 v    v  otherwise, .+ because it must be\n//                                 v    v  *something* there.\n// ['^a', {@ ['i', 'w(?:(!?(?:x|y).*zb$).*)z', 'j' ]}, 'b$']\n//   copy what follows into here--^^^^^\n// ['^a', '(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)', 'b$']\n// ['^a(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)b$']\n\nexport type ExtglobType = '!' | '?' | '+' | '*' | '@'\nconst types = new Set<ExtglobType>(['!', '?', '+', '*', '@'])\nconst isExtglobType = (c: string): c is ExtglobType =>\n  types.has(c as ExtglobType)\n\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))'\nconst startNoDot = '(?!\\\\.)'\n\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.'])\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.'])\nconst reSpecials = new Set('().*{}+?[]^$\\\\!')\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// any single thing other than /\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?'\n\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\n\nexport class AST {\n  type: ExtglobType | null\n  readonly #root: AST\n\n  #hasMagic?: boolean\n  #uflag: boolean = false\n  #parts: (string | AST)[] = []\n  readonly #parent?: AST\n  readonly #parentIndex: number\n  #negs: AST[]\n  #filledNegs: boolean = false\n  #options: MinimatchOptions\n  #toString?: string\n  // set to true if it's an extglob with no children\n  // (which really means one child of '')\n  #emptyExt: boolean = false\n\n  constructor(\n    type: ExtglobType | null,\n    parent?: AST,\n    options: MinimatchOptions = {}\n  ) {\n    this.type = type\n    // extglobs are inherently magical\n    if (type) this.#hasMagic = true\n    this.#parent = parent\n    this.#root = this.#parent ? this.#parent.#root : this\n    this.#options = this.#root === this ? options : this.#root.#options\n    this.#negs = this.#root === this ? [] : this.#root.#negs\n    if (type === '!' && !this.#root.#filledNegs) this.#negs.push(this)\n    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0\n  }\n\n  get hasMagic(): boolean | undefined {\n    /* c8 ignore start */\n    if (this.#hasMagic !== undefined) return this.#hasMagic\n    /* c8 ignore stop */\n    for (const p of this.#parts) {\n      if (typeof p === 'string') continue\n      if (p.type || p.hasMagic) return (this.#hasMagic = true)\n    }\n    // note: will be undefined until we generate the regexp src and find out\n    return this.#hasMagic\n  }\n\n  // reconstructs the pattern\n  toString(): string {\n    if (this.#toString !== undefined) return this.#toString\n    if (!this.type) {\n      return (this.#toString = this.#parts.map(p => String(p)).join(''))\n    } else {\n      return (this.#toString =\n        this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')')\n    }\n  }\n\n  #fillNegs() {\n    /* c8 ignore start */\n    if (this !== this.#root) throw new Error('should only call on root')\n    if (this.#filledNegs) return this\n    /* c8 ignore stop */\n\n    // call toString() once to fill this out\n    this.toString()\n    this.#filledNegs = true\n    let n: AST | undefined\n    while ((n = this.#negs.pop())) {\n      if (n.type !== '!') continue\n      // walk up the tree, appending everthing that comes AFTER parentIndex\n      let p: AST | undefined = n\n      let pp = p.#parent\n      while (pp) {\n        for (\n          let i = p.#parentIndex + 1;\n          !pp.type && i < pp.#parts.length;\n          i++\n        ) {\n          for (const part of n.#parts) {\n            /* c8 ignore start */\n            if (typeof part === 'string') {\n              throw new Error('string part in extglob AST??')\n            }\n            /* c8 ignore stop */\n            part.copyIn(pp.#parts[i])\n          }\n        }\n        p = pp\n        pp = p.#parent\n      }\n    }\n    return this\n  }\n\n  push(...parts: (string | AST)[]) {\n    for (const p of parts) {\n      if (p === '') continue\n      /* c8 ignore start */\n      if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n        throw new Error('invalid part: ' + p)\n      }\n      /* c8 ignore stop */\n      this.#parts.push(p)\n    }\n  }\n\n  toJSON() {\n    const ret: any[] =\n      this.type === null\n        ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n        : [this.type, ...this.#parts.map(p => (p as AST).toJSON())]\n    if (this.isStart() && !this.type) ret.unshift([])\n    if (\n      this.isEnd() &&\n      (this === this.#root ||\n        (this.#root.#filledNegs && this.#parent?.type === '!'))\n    ) {\n      ret.push({})\n    }\n    return ret\n  }\n\n  isStart(): boolean {\n    if (this.#root === this) return true\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!this.#parent?.isStart()) return false\n    if (this.#parentIndex === 0) return true\n    // if everything AHEAD of this is a negation, then it's still the \"start\"\n    const p = this.#parent\n    for (let i = 0; i < this.#parentIndex; i++) {\n      const pp = p.#parts[i]\n      if (!(pp instanceof AST && pp.type === '!')) {\n        return false\n      }\n    }\n    return true\n  }\n\n  isEnd(): boolean {\n    if (this.#root === this) return true\n    if (this.#parent?.type === '!') return true\n    if (!this.#parent?.isEnd()) return false\n    if (!this.type) return this.#parent?.isEnd()\n    // if not root, it'll always have a parent\n    /* c8 ignore start */\n    const pl = this.#parent ? this.#parent.#parts.length : 0\n    /* c8 ignore stop */\n    return this.#parentIndex === pl - 1\n  }\n\n  copyIn(part: AST | string) {\n    if (typeof part === 'string') this.push(part)\n    else this.push(part.clone(this))\n  }\n\n  clone(parent: AST) {\n    const c = new AST(this.type, parent)\n    for (const p of this.#parts) {\n      c.copyIn(p)\n    }\n    return c\n  }\n\n  static #parseAST(\n    str: string,\n    ast: AST,\n    pos: number,\n    opt: MinimatchOptions\n  ): number {\n    let escaping = false\n    let inBrace = false\n    let braceStart = -1\n    let braceNeg = false\n    if (ast.type === null) {\n      // outside of a extglob, append until we find a start\n      let i = pos\n      let acc = ''\n      while (i < str.length) {\n        const c = str.charAt(i++)\n        // still accumulate escapes at this point, but we do ignore\n        // starts that are escaped\n        if (escaping || c === '\\\\') {\n          escaping = !escaping\n          acc += c\n          continue\n        }\n\n        if (inBrace) {\n          if (i === braceStart + 1) {\n            if (c === '^' || c === '!') {\n              braceNeg = true\n            }\n          } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n            inBrace = false\n          }\n          acc += c\n          continue\n        } else if (c === '[') {\n          inBrace = true\n          braceStart = i\n          braceNeg = false\n          acc += c\n          continue\n        }\n\n        if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n          ast.push(acc)\n          acc = ''\n          const ext = new AST(c, ast)\n          i = AST.#parseAST(str, ext, i, opt)\n          ast.push(ext)\n          continue\n        }\n        acc += c\n      }\n      ast.push(acc)\n      return i\n    }\n\n    // some kind of extglob, pos is at the (\n    // find the next | or )\n    let i = pos + 1\n    let part = new AST(null, ast)\n    const parts: AST[] = []\n    let acc = ''\n    while (i < str.length) {\n      const c = str.charAt(i++)\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping\n        acc += c\n        continue\n      }\n\n      if (inBrace) {\n        if (i === braceStart + 1) {\n          if (c === '^' || c === '!') {\n            braceNeg = true\n          }\n        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n          inBrace = false\n        }\n        acc += c\n        continue\n      } else if (c === '[') {\n        inBrace = true\n        braceStart = i\n        braceNeg = false\n        acc += c\n        continue\n      }\n\n      if (isExtglobType(c) && str.charAt(i) === '(') {\n        part.push(acc)\n        acc = ''\n        const ext = new AST(c, part)\n        part.push(ext)\n        i = AST.#parseAST(str, ext, i, opt)\n        continue\n      }\n      if (c === '|') {\n        part.push(acc)\n        acc = ''\n        parts.push(part)\n        part = new AST(null, ast)\n        continue\n      }\n      if (c === ')') {\n        if (acc === '' && ast.#parts.length === 0) {\n          ast.#emptyExt = true\n        }\n        part.push(acc)\n        acc = ''\n        ast.push(...parts, part)\n        return i\n      }\n      acc += c\n    }\n\n    // unfinished extglob\n    // if we got here, it was a malformed extglob! not an extglob, but\n    // maybe something else in there.\n    ast.type = null\n    ast.#hasMagic = undefined\n    ast.#parts = [str.substring(pos - 1)]\n    return i\n  }\n\n  static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n    const ast = new AST(null, undefined, options)\n    AST.#parseAST(pattern, ast, 0, options)\n    return ast\n  }\n\n  // returns the regular expression if there's magic, or the unescaped\n  // string if not.\n  toMMPattern(): MMRegExp | string {\n    // should only be called on root\n    /* c8 ignore start */\n    if (this !== this.#root) return this.#root.toMMPattern()\n    /* c8 ignore stop */\n    const glob = this.toString()\n    const [re, body, hasMagic, uflag] = this.toRegExpSource()\n    // if we're in nocase mode, and not nocaseMagicOnly, then we do\n    // still need a regular expression if we have to case-insensitively\n    // match capital/lowercase characters.\n    const anyMagic =\n      hasMagic ||\n      this.#hasMagic ||\n      (this.#options.nocase &&\n        !this.#options.nocaseMagicOnly &&\n        glob.toUpperCase() !== glob.toLowerCase())\n    if (!anyMagic) {\n      return body\n    }\n\n    const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '')\n    return Object.assign(new RegExp(`^${re}$`, flags), {\n      _src: re,\n      _glob: glob,\n    })\n  }\n\n  get options() {\n    return this.#options\n  }\n\n  // returns the string match, the regexp source, whether there's magic\n  // in the regexp (so a regular expression is required) and whether or\n  // not the uflag is needed for the regular expression (for posix classes)\n  // TODO: instead of injecting the start/end at this point, just return\n  // the BODY of the regexp, along with the start/end portions suitable\n  // for binding the start/end in either a joined full-path makeRe context\n  // (where we bind to (^|/), or a standalone matchPart context (where\n  // we bind to ^, and not /).  Otherwise slashes get duped!\n  //\n  // In part-matching mode, the start is:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n  // - if dots allowed or not possible: ^\n  // - if dots possible and not allowed: ^(?!\\.)\n  // end is:\n  // - if not isEnd(): nothing\n  // - else: $\n  //\n  // In full-path matching mode, we put the slash at the START of the\n  // pattern, so start is:\n  // - if first pattern: same as part-matching mode\n  // - if not isStart(): nothing\n  // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n  // - if dots allowed or not possible: /\n  // - if dots possible and not allowed: /(?!\\.)\n  // end is:\n  // - if last pattern, same as part-matching mode\n  // - else nothing\n  //\n  // Always put the (?:$|/) on negated tails, though, because that has to be\n  // there to bind the end of the negated pattern portion, and it's easier to\n  // just stick it in now rather than try to inject it later in the middle of\n  // the pattern.\n  //\n  // We can just always return the same end, and leave it up to the caller\n  // to know whether it's going to be used joined or in parts.\n  // And, if the start is adjusted slightly, can do the same there:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n  // - if dots allowed or not possible: (?:/|^)\n  // - if dots possible and not allowed: (?:/|^)(?!\\.)\n  //\n  // But it's better to have a simpler binding without a conditional, for\n  // performance, so probably better to return both start options.\n  //\n  // Then the caller just ignores the end if it's not the first pattern,\n  // and the start always gets applied.\n  //\n  // But that's always going to be $ if it's the ending pattern, or nothing,\n  // so the caller can just attach $ at the end of the pattern when building.\n  //\n  // So the todo is:\n  // - better detect what kind of start is needed\n  // - return both flavors of starting pattern\n  // - attach $ at the end of the pattern when creating the actual RegExp\n  //\n  // Ah, but wait, no, that all only applies to the root when the first pattern\n  // is not an extglob. If the first pattern IS an extglob, then we need all\n  // that dot prevention biz to live in the extglob portions, because eg\n  // +(*|.x*) can match .xy but not .yx.\n  //\n  // So, return the two flavors if it's #root and the first child is not an\n  // AST, otherwise leave it to the child AST to handle it, and there,\n  // use the (?:^|/) style of start binding.\n  //\n  // Even simplified further:\n  // - Since the start for a join is eg /(?!\\.) and the start for a part\n  // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n  // or start or whatever) and prepend ^ or / at the Regexp construction.\n  toRegExpSource(\n    allowDot?: boolean\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    const dot = allowDot ?? !!this.#options.dot\n    if (this.#root === this) this.#fillNegs()\n    if (!this.type) {\n      const noEmpty = this.isStart() && this.isEnd()\n      const src = this.#parts\n        .map(p => {\n          const [re, _, hasMagic, uflag] =\n            typeof p === 'string'\n              ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n              : p.toRegExpSource(allowDot)\n          this.#hasMagic = this.#hasMagic || hasMagic\n          this.#uflag = this.#uflag || uflag\n          return re\n        })\n        .join('')\n\n      let start = ''\n      if (this.isStart()) {\n        if (typeof this.#parts[0] === 'string') {\n          // this is the string that will match the start of the pattern,\n          // so we need to protect against dots and such.\n\n          // '.' and '..' cannot match unless the pattern is that exactly,\n          // even if it starts with . or dot:true is set.\n          const dotTravAllowed =\n            this.#parts.length === 1 && justDots.has(this.#parts[0])\n          if (!dotTravAllowed) {\n            const aps = addPatternStart\n            // check if we have a possibility of matching . or ..,\n            // and prevent that.\n            const needNoTrav =\n              // dots are allowed, and the pattern starts with [ or .\n              (dot && aps.has(src.charAt(0))) ||\n              // the pattern starts with \\., and then [ or .\n              (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n              // the pattern starts with \\.\\., and then [ or .\n              (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)))\n            // no need to prevent dots if it can't match a dot, or if a\n            // sub-pattern will be preventing it anyway.\n            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0))\n\n            start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : ''\n          }\n        }\n      }\n\n      // append the \"end of path portion\" pattern to negation tails\n      let end = ''\n      if (\n        this.isEnd() &&\n        this.#root.#filledNegs &&\n        this.#parent?.type === '!'\n      ) {\n        end = '(?:$|\\\\/)'\n      }\n      const final = start + src + end\n      return [\n        final,\n        unescape(src),\n        (this.#hasMagic = !!this.#hasMagic),\n        this.#uflag,\n      ]\n    }\n\n    // We need to calculate the body *twice* if it's a repeat pattern\n    // at the start, once in nodot mode, then again in dot mode, so a\n    // pattern like *(?) can match 'x.y'\n\n    const repeated = this.type === '*' || this.type === '+'\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:'\n    let body = this.#partsToRegExp(dot)\n\n    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n      // invalid extglob, has to at least be *something* present, if it's\n      // the entire path portion.\n      const s = this.toString()\n      this.#parts = [s]\n      this.type = null\n      this.#hasMagic = undefined\n      return [s, unescape(this.toString()), false, false]\n    }\n\n    // XXX abstract out this map method\n    let bodyDotAllowed =\n      !repeated || allowDot || dot || !startNoDot\n        ? ''\n        : this.#partsToRegExp(true)\n    if (bodyDotAllowed === body) {\n      bodyDotAllowed = ''\n    }\n    if (bodyDotAllowed) {\n      body = `(?:${body})(?:${bodyDotAllowed})*?`\n    }\n\n    // an empty !() is exactly equivalent to a starNoEmpty\n    let final = ''\n    if (this.type === '!' && this.#emptyExt) {\n      final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty\n    } else {\n      const close =\n        this.type === '!'\n          ? // !() must match something,but !(x) can match ''\n            '))' +\n            (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n            star +\n            ')'\n          : this.type === '@'\n          ? ')'\n          : this.type === '?'\n          ? ')?'\n          : this.type === '+' && bodyDotAllowed\n          ? ')'\n          : this.type === '*' && bodyDotAllowed\n          ? `)?`\n          : `)${this.type}`\n      final = start + body + close\n    }\n    return [\n      final,\n      unescape(body),\n      (this.#hasMagic = !!this.#hasMagic),\n      this.#uflag,\n    ]\n  }\n\n  #partsToRegExp(dot: boolean) {\n    return this.#parts\n      .map(p => {\n        // extglob ASTs should only contain parent ASTs\n        /* c8 ignore start */\n        if (typeof p === 'string') {\n          throw new Error('string type in extglob ast??')\n        }\n        /* c8 ignore stop */\n        // can ignore hasMagic, because extglobs are already always magic\n        const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot)\n        this.#uflag = this.#uflag || uflag\n        return re\n      })\n      .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n      .join('|')\n  }\n\n  static #parseGlob(\n    glob: string,\n    hasMagic: boolean | undefined,\n    noEmpty: boolean = false\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    let escaping = false\n    let re = ''\n    let uflag = false\n    for (let i = 0; i < glob.length; i++) {\n      const c = glob.charAt(i)\n      if (escaping) {\n        escaping = false\n        re += (reSpecials.has(c) ? '\\\\' : '') + c\n        continue\n      }\n      if (c === '\\\\') {\n        if (i === glob.length - 1) {\n          re += '\\\\\\\\'\n        } else {\n          escaping = true\n        }\n        continue\n      }\n      if (c === '[') {\n        const [src, needUflag, consumed, magic] = parseClass(glob, i)\n        if (consumed) {\n          re += src\n          uflag = uflag || needUflag\n          i += consumed - 1\n          hasMagic = hasMagic || magic\n          continue\n        }\n      }\n      if (c === '*') {\n        if (noEmpty && glob === '*') re += starNoEmpty\n        else re += star\n        hasMagic = true\n        continue\n      }\n      if (c === '?') {\n        re += qmark\n        hasMagic = true\n        continue\n      }\n      re += regExpEscape(c)\n    }\n    return [re, unescape(glob), !!hasMagic, uflag]\n  }\n}\n", "import { MinimatchOptions } from './index.js'\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nexport const escape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  // don't need to escape +@! because we escape the parens\n  // that make those magic, and escaping ! as [!] isn't valid,\n  // because [!]] is a valid glob class meaning not ']'.\n  return windowsPathsNoEscape\n    ? s.replace(/[?*()[\\]]/g, '[$&]')\n    : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&')\n}\n", "'use strict';\n/**\n * @author github.com/tintinweb\n * @author github.com/jsbinette\n *\n *\n * */\nimport * as vscode from 'vscode'\n\nexport function extensionConfig(): vscode.WorkspaceConfiguration {\n    return vscode.workspace.getConfiguration('instructions-manager');\n}"],
  "mappings": "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",
  "names": ["module", "module", "expand", "vscode", "path", "start", "final", "i", "acc", "ext", "_hasMagic", "ext", "qmark", "star", "expand", "regExpEscape", "filter", "ext", "match", "NodeType"]
}
