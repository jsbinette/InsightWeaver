{
  "version": 3,
  "sources": ["../../src/webviews/tree-data-view.ts", "../../src/utilities/utility.service.ts"],
  "sourcesContent": ["'use strict';\n\nimport * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\nimport { getExtensionConfig } from '../utilities/utility.service';\nimport { TagsController } from '../utilities/tagsController';\n\n\nclass TagsDataModel {\n    private controller: TagsController;\n\n    constructor(controller: TagsController) {\n        this.controller = controller;\n    }\n\n    getRoot(): TreeElement[] {\n        let fileTags = Object.keys(this.controller.tags);\n\n        if (getExtensionConfig().view.showVisibleFilesOnly) {\n            let visibleEditorUris: string[];\n\n            if (getExtensionConfig().view.showVisibleFilesOnlyMode === 'onlyActiveEditor') {\n                const activeEditor = vscode.window.activeTextEditor;\n                visibleEditorUris = activeEditor ? [activeEditor.document.uri.path] : [];\n            } else {\n                visibleEditorUris = vscode.window.visibleTextEditors.map((te) => te.document.uri.path);\n            }\n\n            fileTags = fileTags.filter((v) =>\n                visibleEditorUris.includes(vscode.Uri.parse(v).path)\n            );\n        }\n\n        return fileTags.sort().map((v) => ({\n            resource: vscode.Uri.parse(v),\n            tooltip: v,\n            name: v,\n            type: NodeType.FILE,\n            parent: null,\n            iconPath: vscode.ThemeIcon.File,\n            location: null,\n            label: path.basename(vscode.Uri.parse(v).fsPath)\n        }));\n    }\n\n    getChildren(element: TreeElement): TreeElement[] {\n        if (element.type === NodeType.FILE) {\n            const extractTextAfterLastAtWord = (inputString: string): string => {\n                const zeroedRegex = /^@summarize\\([^)]*\\)\\s*/;\n                const zeroedMatch = inputString.match(zeroedRegex);\n                if (zeroedMatch) {\n                    return zeroedMatch[0].trim();\n                }\n\n                const firstRegex = /@[\\w-]+[^@]*$/;\n                const firstMatch = inputString.match(firstRegex);\n\n                if (firstMatch) {\n                    let remainingText = firstMatch[0];\n                    let secondRegex: RegExp;\n\n                    while (true) {\n                        if (remainingText.startsWith('@summarize(')) {\n                            secondRegex = /^@summarize\\([^)]*\\)\\s*/;\n                        } else {\n                            secondRegex = /^@[\\w-]+\\s+/;\n                        }\n\n                        const secondMatch = remainingText.match(secondRegex);\n\n                        if (secondMatch) {\n                            remainingText = remainingText.substring(secondMatch[0].length);\n                        } else {\n                            break;\n                        }\n                    }\n\n                    return remainingText.trim();\n                }\n\n                return '';\n            };\n\n            const tags = Object.keys(this.controller.tags[element.name]).flatMap((cat) => {\n                return this.controller.tags[element.name][cat].map((v: any) => {\n                    const location = new vscode.Location(element.resource, v.range);\n                    return {\n                        resource: element.resource,\n                        location: location,\n                        label: extractTextAfterLastAtWord(v.text),\n                        name: v.text.trim(),\n                        type: NodeType.LOCATION,\n                        category: cat,\n                        parent: element,\n                        iconPath: this.controller.styles[cat]?.options?.gutterIconPath,\n                    };\n                });\n            });\n\n            return tags.sort((a, b) => a.location!.range.start.line - b.location!.range.start.line);\n        }\n\n        return [];\n    }\n\n    getNeighbors(element: TreeElement): { previous: TreeElement | null; next: TreeElement | null } {\n        const ret: { previous: TreeElement | null; next: TreeElement | null } = { previous: null, next: null };\n        let parent = element.parent;\n\n        if (!parent) {\n            parent = { ...element, type: NodeType.FILE, name: element.resource.toString() } as TreeElement;\n        }\n\n        const tags = this.getChildren(parent);\n\n        let gotElement = false;\n\n        for (const b of tags) {\n            if (!gotElement && JSON.stringify(b.location) === JSON.stringify(element.location)) {\n                gotElement = true;\n                continue;\n            }\n\n            if (!gotElement) {\n                ret.previous = b;\n            } else {\n                ret.next = b;\n                break;\n            }\n        }\n\n        return ret;\n    }\n}\n\n\nexport class TagsTreeDataProvider implements vscode.TreeDataProvider<TreeElement> {\n    private _onDidChangeTreeData: vscode.EventEmitter<TreeElement | undefined | null | void> = new vscode.EventEmitter<TreeElement | undefined | null | void>();\n    readonly onDidChangeTreeData: vscode.Event<TreeElement | undefined | null | void> = this._onDidChangeTreeData.event;\n\n    private controller: any; // Replace `any` with the actual type of your instructionsController\n    public model: TagsDataModel;\n    private filterTreeViewWords: string[];\n    private gitIgnoreHandler: { filter: (resource: vscode.Uri) => boolean } | undefined;\n\n    constructor(instructionsController: any) {\n        this.controller = instructionsController;\n        this.model = new TagsDataModel(instructionsController);\n        this.filterTreeViewWords = [];\n        this.gitIgnoreHandler = undefined;\n    }\n\n    /** TreeDataProvider Methods */\n\n    public getChildren(element?: TreeElement): Thenable<TreeElement[]> {\n        const elements = element ? this.model.getChildren(element) : this.model.getRoot();\n        return Promise.resolve(this._filterTreeView(elements));\n    }\n\n    getParent(element: TreeElement): TreeElement | null {\n        return element.parent || null;\n    }\n\n    getTreeItem(element: TreeElement): vscode.TreeItem {\n        let label = this._formatLabel(element.label)\n        if (label == undefined) {\n            label = \"\"\n        }\n        const item = new vscode.TreeItem(\n            label, // Pass a valid label\n            element.type === NodeType.LOCATION\n                ? vscode.TreeItemCollapsibleState.None\n                : getExtensionConfig().view.expanded\n                    ? vscode.TreeItemCollapsibleState.Expanded\n                    : vscode.TreeItemCollapsibleState.Collapsed\n        );\n\n        item.id =\n            element.type === NodeType.LOCATION && element.location\n                ? this._getId(element.location)\n                : this._getId(element.resource);\n\n        item.resourceUri = element.resource;\n        item.iconPath = element.iconPath;\n        item.command =\n            element.type === NodeType.LOCATION && element.location\n                ? {\n                    command: \"instructions-manager.jumpToRange\",\n                    arguments: [element.location.uri, element.location.range],\n                    title: \"JumpTo\",\n                }\n                : undefined;\n\n        return item;\n    }\n\n    /** Utility Methods */\n\n    private _getId(o: vscode.Location | vscode.Uri): string {\n        return crypto.createHash('sha1').update(JSON.stringify(o)).digest('hex');\n    }\n\n    private _formatLabel(label?: string): string | undefined {\n        if (!getExtensionConfig().view.words.hide || !label) {\n            return label;\n        }\n        const words = Object.values(this.controller.words).flat() as string[];\n        return words.reduce((prevs, word) => prevs.replace(new RegExp(word, 'g'), ''), label);\n    }\n\n    /// Jan2025 JSB I left this function there but it doesn't work\n    /// because the label passed to the the three is not 'just' the label\n    /// I'm skipping the file level types (type 1) so the filter would not be that\n    /// great anyway because the files would still ALL show\n    private _filterTreeView(elements: TreeElement[]): TreeElement[] {\n        if (this.gitIgnoreHandler?.filter) {\n            elements = elements.filter((e) => this.gitIgnoreHandler!.filter(e.resource));\n        }\n\n        if (this.filterTreeViewWords.length) {\n            elements = elements.filter((e) => {\n                if (e.type === 1) {\n                    return true; // Include all elements of type=1\n                } else if (e.type === 2) {\n                    return this.filterTreeViewWords.some((rx) => new RegExp(rx, 'g').test(e.label || ''));\n                }\n                return false; // Exclude elements of other types\n            });\n        }\n\n        return elements;\n    }\n\n    /** Public Methods */\n\n    setTreeViewFilterWords(words: string[]): void {\n        this.filterTreeViewWords = words;\n    }\n\n    setTreeViewGitIgnoreHandler(gi: { filter: (resource: vscode.Uri) => boolean }): void {\n        this.gitIgnoreHandler = gi;\n    }\n\n    refresh(): void {\n        this._onDidChangeTreeData.fire();\n    }\n}\n\n/**\n * Finds the nearest tag in a document.\n * @param documentUri The URI of the document.\n * @param treeDataProvider The tree data provider for tags.\n * @param anchor The position to anchor the search to.\n * @param overrideStrategy Optional strategy to override the default follow mode.\n * @returns The nearest tag, if any.\n */\nexport async function editorFindNearestTag(\n    documentUri: vscode.Uri,\n    treeDataProvider: TagsTreeDataProvider,\n    anchor: vscode.Position,\n    overrideStrategy?: string\n): Promise<TreeElement | null> {\n    const children = await treeDataProvider.getChildren(); // Wait for the promise to resolve\n    const root = children.find((f) => f.name === documentUri.toString());\n\n    if (!root) {\n        return null; // File not found\n    }\n\n    const focusLine = anchor.line;\n\n    // Strategy: nearest tag\n    function strategyNearestTag(previous: TreeElement | null, current: TreeElement): TreeElement {\n        if (!previous) return current;\n        return Math.abs(focusLine - current.location!.range.start.line) <=\n            Math.abs(focusLine - previous.location!.range.start.line)\n            ? current\n            : previous;\n    }\n\n    // Strategy: previous tag (chapter style)\n    function strategyLastKnownTag(previous: TreeElement | null, current: TreeElement): TreeElement {\n        if (!previous) return current;\n        return focusLine >= current.location!.range.start.line &&\n            focusLine - current.location!.range.start.line <=\n            focusLine - previous.location!.range.start.line\n            ? current\n            : previous;\n    }\n\n    let followMode = strategyNearestTag;\n    const strategy = overrideStrategy || getExtensionConfig().view.followMode;\n\n    switch (strategy) {\n        case 'chapter':\n            followMode = strategyLastKnownTag;\n            break;\n        case 'nearest':\n        default:\n            followMode = strategyNearestTag;\n    }\n\n    const tags = await treeDataProvider.getChildren(root);\n\n    return tags.reduce<TreeElement | null>((prev, current) => followMode(prev, current), null);\n}\n\n/**\n * Jumps to the specified range in a text editor.\n * @param range The range to jump to.\n * @param editor Optional editor to use, defaults to the active editor.\n */\nexport function editorJumptoRange(range: vscode.Range, editor?: vscode.TextEditor): void {\n    editor = editor || vscode.window.activeTextEditor; // Provided editor or fallback to active\n\n    if (!editor) return; // No active editor, nothing to do\n\n    let revealType = vscode.TextEditorRevealType.InCenter;\n    const selection = new vscode.Selection(\n        range.start.line,\n        range.start.character,\n        range.end.line,\n        range.end.character\n    );\n\n    if (range.start.line === editor.selection.active.line) {\n        revealType = vscode.TextEditorRevealType.InCenterIfOutsideViewport;\n    }\n\n    editor.selection = selection;\n    editor.revealRange(selection, revealType);\n}\n\n\nexport async function jumpToPrevious(treeView: vscode.TreeView<TreeElement>, treeDataProvider: TagsTreeDataProvider): Promise<void> {\n    const activeEditor = vscode.window.activeTextEditor;\n    let element: TreeElement | null = null;\n    const lineMode = getExtensionConfig().view.lineMode;\n\n    if (treeView.visible && treeView.selection.length && lineMode === \"selected-tag\") {\n        // TreeView is visible and an item is selected\n        element = treeView.selection[0];\n    } else {\n        // No selection, find the nearest tag in the editor\n        if (!activeEditor || !activeEditor.selections.length || !activeEditor.document) {\n            return;\n        }\n        element = await editorFindNearestTag(\n            activeEditor.document.uri,\n            treeDataProvider,\n            activeEditor.selections[0].anchor,\n            \"chapter\"\n        );\n    }\n\n    if (!element) {\n        return;\n    }\n\n    const neighbors = treeDataProvider.model.getNeighbors(element);\n    let target = neighbors.previous;\n\n    if (\n        lineMode === \"current-line\" &&\n        activeEditor &&\n        activeEditor.selections[0].anchor.line > element.location!.range.start.line\n    ) {\n        // Override to \"element\" except when the anchor is on the same line as the tag\n        target = element;\n    }\n\n    if (target && target.location) {\n        vscode.workspace.openTextDocument(target.location.uri).then((doc) => {\n            vscode.window.showTextDocument(doc).then((editor) => {\n                editorJumptoRange(target.location!.range, editor);\n            });\n        });\n    }\n}\n\nexport async function jumpToNext(treeView: vscode.TreeView<TreeElement>, treeDataProvider: TagsTreeDataProvider): Promise<void> {\n    const activeEditor = vscode.window.activeTextEditor;\n    let element: any;\n    const lineMode = getExtensionConfig().view.lineMode;\n\n    if (treeView.visible && treeView.selection.length && lineMode === 'selected-tag') {\n        // TreeView is visible and item selected\n        element = treeView.selection[0];\n    } else {\n        // No selection, find nearest tag in editor\n        if (!activeEditor || !activeEditor.selections.length || !activeEditor.document) {\n            return;\n        }\n        element = editorFindNearestTag(\n            activeEditor.document.uri,\n            treeDataProvider,\n            activeEditor.selections[0].anchor,\n            'chapter'\n        );\n    }\n\n    if (!element) {\n        return;\n    }\n\n    const neighbors = treeDataProvider.model.getNeighbors(element);\n    let target = neighbors.next;\n\n    if (\n        lineMode === 'current-line' &&\n        !neighbors.previous &&\n        activeEditor &&\n        activeEditor.selections[0].anchor.line < element.location.range.start.line\n    ) {\n        // When lineMode is enabled, the chapter \"next\" target is almost always correct,\n        // except when the anchor is before the first tag\n        target = element;\n    }\n\n    if (target && target.location) {\n        vscode.workspace.openTextDocument(target.location.uri).then((doc) => {\n            vscode.window.showTextDocument(doc).then((editor) => {\n                editorJumptoRange(target.location!.range, editor);\n            });\n        });\n    }\n}\n\nexport function chooseFilterWords(words: string[] | undefined, treeDataProvider: TagsTreeDataProvider) {\n    if (!words || !words.length) {\n        // Show input dialog if no words are provided\n        const options: vscode.InputBoxOptions = {\n            prompt: \"Filter Tags View:\",\n            placeHolder: \"(e.g. @audit-info; @follow-up; leave empty to disable filter)\",\n        };\n\n        vscode.window.showInputBox(options).then((value) => {\n            const filterWords = value\n                ? value.trim().split(/[\\s;]+/).map((v) => v.trim()).filter((v) => v.length > 0)\n                : [];\n            treeDataProvider.setTreeViewFilterWords(filterWords);\n        });\n    } else {\n        // Words provided directly (e.g., by another extension)\n        treeDataProvider.setTreeViewFilterWords(words);\n    }\n}\n\n\nenum NodeType {\n    FILE = 1,\n    LOCATION = 2,\n}\n\nexport interface TreeElement {\n    resource: vscode.Uri;\n    tooltip?: string;\n    name: string;\n    type: NodeType;\n    parent: TreeElement | null;\n    iconPath: vscode.ThemeIcon | string | undefined;\n    location?: vscode.Location | null;\n    label?: string;\n    category?: string;\n}", "import * as vscode from \"vscode\";\nimport EventEmitter = require('events');\n\nexport function getExtensionConfig(): vscode.WorkspaceConfiguration {\n    return vscode.workspace.getConfiguration('instructions-manager');\n}\n\n\n/**\n * Click history question event emitter.\n */\nconst clickHistoryQuestionEventEmitter = new EventEmitter();\nexport { clickHistoryQuestionEventEmitter }\n\n/**\n * Fire history question event.\n * @param historyQuestion :string \n*/\nexport function FireClickHistoryQuestionEvent(historyQuestion: string) {\n  clickHistoryQuestionEventEmitter.emit('clickHistoryQuestion', historyQuestion);\n}\n\n/**\n * Gets nonce\n * @returns string\n */\nexport function getNonce() {\n  let text = \"\";\n  const possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  for (let i = 0; i < 32; i++) {\n    text += possible.charAt(Math.floor(Math.random() * possible.length));\n  }\n  return text;\n}\n\n/**\n * Create a vscode.Uri as WebviewUri for source files.\n * @param webview :vscode.Weview\n * @param extensionUri :vscode.Uri\n * @param pathList :string[]\n * @returns vscode.Uri\n */\nexport function getAsWebviewUri(webview: vscode.Webview, extensionUri: vscode.Uri, pathList: string[]) {\n  return webview.asWebviewUri(vscode.Uri.joinPath(extensionUri, ...pathList));\n}\n\n/**\n * Create a vscode.Uri for source files.\n * @param extensionUri :vscode.Uri\n * @param pathList :strig[]\n * @returns vscode.Uri\n */\nexport function getVSCodeUri(extensionUri: vscode.Uri, pathList: string[]) {\n  return vscode.Uri.joinPath(extensionUri, ...pathList);\n}\n\n/**\n * Set storeData into context.globalState.\n * @param context :vscode.ExtensionContext\n * @param storeData : any\n */\nexport function setStoreData(context: vscode.ExtensionContext, storeData: any) {\n  const state = globalStateManager(context);\n\n  if (storeData !== undefined) {\n    state.write({\n      storeData: storeData\n    });\n  }\n}\n\nexport function setHistoryData(context: vscode.ExtensionContext, historyData: any) {\n  const state = globalStateManager(context);\n\n  if (historyData !== undefined) {\n    state.writeHistory({\n      historyData: historyData\n    });\n  }\n}\n\nexport function setChatData(context: vscode.ExtensionContext, chatData: any) {\n  const state = globalStateManager(context);\n\n  if (chatData !== undefined) {\n    state.writeChat({\n      chatData: chatData\n    });\n  }\n}\n\n/**\n * Gets storeData from context.globalState.\n * @param context :vscode.ExtensionContext\n * @returns string\n */\nexport function getStoreData(context: vscode.ExtensionContext): any {\n  const state = globalStateManager(context);\n\n  const { storeData } = state.read();\n  return storeData as any;\n}\n\nexport function getHistoryData(context: vscode.ExtensionContext): any {\n  const state = globalStateManager(context);\n\n  const { historyData } = state.readHistory();\n  return historyData as any;\n}\n\nexport function getChatData(context: vscode.ExtensionContext): any {\n  const state = globalStateManager(context);\n\n  const { chatData } = state.readChat();\n  return chatData as any;\n}\n\n/**\n* State Manager has read and write methods for api key. This methods set and get the api key from context.globalState.\n* @param context :vscode.ExtensionContext.\n* @returns void.\n*/\nexport function globalStateManager(context: vscode.ExtensionContext) {\n  return {\n    read,\n    write,\n    writeHistory,\n    readHistory,\n    writeChat,\n    readChat,\n  };\n\n  function read() {\n    return {\n      storeData: context.globalState.get('storeData')\n    };\n  }\n  \n  function readHistory() {\n    var historyData =  context.globalState.get('historyData')\n    if(historyData == undefined){\n      historyData = [];\n    }\n    return {\n      historyData\n    };\n  }\n\n  function readChat() {\n    var chatData =  context.globalState.get('chatData')\n    if(chatData == undefined){\n      chatData = [];\n    }\n    return {\n      chatData\n    };\n  }\n\n  function write(newState: any) {\n    context.globalState.update('storeData', newState.storeData);\n  }\n\n  function writeChat(newState: any) {\n    context.globalState.update('chatData', newState.chatData);\n  }\n\n  function writeHistory(newState: any) {\n    context.globalState.update('historyData', newState.historyData);\n  }\n}\n\n"],
  "mappings": "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",
  "names": ["vscode", "NodeType"]
}
